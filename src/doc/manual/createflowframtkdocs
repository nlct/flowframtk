#!/usr/bin/perl -w

use strict;
use XML::Parser;

# createflowframtkdocs FlowframTk en GB
# createflowframtkdocs FlowframTk en US
# createflowframtkdocs JDRView en GB
# createflowframtkdocs JDRView en US

if ($#ARGV > 2 || $#ARGV < 0)
{
   die "Syntax: $0 <base> <lang> [<region>]\n";
}

my $base = lc($ARGV[0]);
my $lang = $ARGV[1];

my $locale = $lang;

if ($#ARGV == 2)
{
  $locale .= "-".$ARGV[2];
}

my $downloadurl = 'https://www.dickimaw-books.com/software/flowframtk/';
my $targetdir = '../../lib/resources/helpsets';
my $dictdir = '../../lib/resources/dictionaries';
my $mainclass = "../../java/$base/" . $ARGV[0] . 'Invoker.java';

my $fontenc = 'T1';

my %bibentries = ();
my $bibpending = '';

# mapping between locales and babel options

my %babel =
 (
    'en'    => 'english',
    'en-GB' => 'british',
    'en-US' => 'american',
    'fr'    => 'frenchb'
 );

my $encoding_file = 'utf8';
my $encoding_xml  = 'UTF-8';

my $fd;
open $fd, "$mainclass" or die "Can't open main class file '$mainclass' $!\n";
binmode($fd, ":$encoding_file");

my %dict = ();

while (<$fd>)
{
   if (/public +static +final +String +APP_NAME *= *"([^"]+)"/)
   {
      $dict{appname} = $1;
   }
   elsif (/public +static +final +String +APP_VERSION *= *"([^"]+)"/)
   {
      $dict{appversion} = $1;
   }
   elsif (/public +static +final +String +APP_DATE *= *"([^"]+)"/)
   {
      $dict{appdate} = $1;
   }
}

close $fd;

my $propfile = "$dictdir/$base-$locale.prop";

if (not (-e $propfile) and ($lang ne $locale))
{
   $propfile = "$dictdir/$base-$lang.prop";

   unless (-e $propfile)
   {
      die "Can't find either '$dictdir/$base-$locale.prop' or '$propfile'\n";
   }
}

unless (-e $propfile)
{
   die "Can't find '$propfile'\n";
}

open $fd, "$propfile" or die "Can't open property file '$propfile' $!\n";

$_ = <$fd>;

if (/# Encoding: ([^s]+)/)
{
   binmode($fd, ":encoding($1)");
}
else
{
   die "Encoding comment line missing from line 1 of '$propfile'\n";
}

my $linenum = 0;

my $openquote = chr(hex(2018));
my $closequote = chr(hex(2019));

while (<$fd>)
{
   $linenum++;

   next if (/^ *#/ or /^ *$/);

   if (/^([^=]+)=(.*)$/)
   {
      my $dictkey = $1;
      my $value = $2;

      $value=~s/\\{1}[nt]/ /g;
      $value=~s/(\w)''(\w)/$1$closequote$2/g;
      $value=~s/'{2}([^']+)'{2}/$openquote$1$closequote/g;
      $value=~s/'{2}/$closequote/g;
      $value=~s/\|([a-zA-Z]+)\|/\\cs{$1}/g;

      # strip any trailing ellipsis
      $value=~s/\.{3}$//g;

      # Prop files don't contain any literal {n,...,...}
      # Don't need the complexity of the Java application here.
      # (Many of the messages aren't used in the manual.)

      $value=~s/\{\d,choice,[^\}]+\|<([^\}]*)\}/$1/g;

      $value=~s/\{(\d+)(,[^\}]+)?\}/&arg_placeholder($1)/eg;

      $dict{$dictkey} = $value;

   }
   else
   {
      warn "$propfile: Can't parse line $linenum\n";
   }
}

close $fd;

my %docinfo = ();
my @nodes   = ();
my @current = ();
my @paragraph = ();
my %tags    = ();
my $currenttag= '';
my $includehtml = 1;
my $includetex = 1;
my $boilerplate = 0;

my $languagedefinitions = 
  "\\def\\applang{$locale}\n"
 ."\\def\\idxpackagename{".&get_label('manual.idxpackage')."}\n"
 ."\\def\\idxenvname{".&get_label('manual.idxenv')."}\n"
 ."\\def\\examplename{".&get_label('manual.example')."}\n"
 ."\\def\\abbrvname{".&get_label('manual.abbreviations')."}\n";

my $xmlfile = "$base-$locale.xml";

if (not (-e $xmlfile) and ($lang ne $locale))
{
   $xmlfile = "$base-$lang.xml";

   unless (-e $xmlfile)
   {
      die "Can't find either '$base-$locale.xml' or '$xmlfile'\n";
   }
}

unless (-e $xmlfile)
{
   die "Can't find '$xmlfile'\n";
}

my $texfile = "$base-$locale.tex";
my $bibfile = "$base-$locale.bib";
my $boilerplatefile = "$base-$locale-boilerplate.tex";

my $helpsetdir = "$targetdir/$base/$locale";

unless (-e $helpsetdir)
{
   mkdir $helpsetdir or die "Can't mkdir '$helpsetdir' $!\n";
}

unless (-d $helpsetdir)
{
   die "'$helpsetdir' is not a directory\n";
}

# Is there any way of querying the input encoding picked up by
# XML::Parser? Let's just stick to utf8
my $inputenc = 'utf8';
 
my %section_levels =
(
   'chapter'       => '1',
   'section'       => '2',
   'subsection'    => '3',
   'subsubsection' => '4',
   'paragraph'     => '5'
);

my %acros = ();

my %terms = ();

my @float_elements = ();

my @tabular_specs = ();

my %counters = ();

my $boilerfd;
my $texfd;
my $bibfd;

# open the TeX file
open $texfd, ">$texfile" or die "Can't open TeX file '$texfile' $!\n";
binmode($texfd, ":$encoding_file");

# open the bib file
open $bibfd, ">$bibfile" or die "Can't open Bib file '$bibfile' $!\n";
binmode($bibfd, ":$encoding_file");
print $bibfd "% Encoding: $encoding_xml\n";

print $bibfd '@preamble{"\\providecommand{\\optnoindex}[1]{--#1}"}', "\n";
 
# initialize the parser
my $parser = XML::Parser->new( Handlers => 
                                     {
                                      Start=>\&handle_start,
                                      End=>\&handle_end,
                                      Char=>\&handle_char
                                     });
$parser->parsefile( $xmlfile );
 
close $texfd;
close $bibfd;

# Write helpset files

my $hsfd;
open $hsfd, ">$helpsetdir/$base.hs"
  or die "Can't open '$helpsetdir/$base.hs' $!\n";
binmode($hsfd, ":$encoding_file");

my $toctitle = &get_label('manual.toc');
my $manualtitle = &get_label('manual.title');
my $indextitle = &get_label('manual.index');
my $searchtitle = &get_label('manual.search');

print $hsfd <<_END_HS_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
<!DOCTYPE helpset
PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp HelpSet Version 2.0//EN"
"http://java.sun.com/products/javahelp/helpset_2_0.dtd">


<helpset version="2.0">
   <!-- title -->
   <title>$manualtitle</title>
   <!-- maps -->
   <maps>
   <homeID>top </homeID>
   <mapref location="Map.jhm" />
   </maps>

   <!-- views -->
   <view xml:lang="$locale" mergetype="javax.help.UniteAppendMerge">
      <name>TOC</name>
      <label>$toctitle</label>
      <type>javax.help.TOCView</type>
      <data>${base}TOC.xml</data>
   </view>
   <view xml:lang="$locale" mergetype="javax.help.SortMerge">
      <name>Index</name>
      <label>$indextitle</label>
      <type>javax.help.IndexView</type>
      <data>${base}Index.xml</data>
   </view>
   <view xml:lang="$locale">
      <name>Search</name>
      <label>$searchtitle</label>
      <type>javax.help.SearchView</type>
         <data engine="com.sun.java.help.search.DefaultSearchEngine">
         JavaHelpSearch
         </data>
   </view>
   <!-- presentation windows -->
   <!-- main window -->
   <presentation default=true>
      <name>main window</name>
      <size width="600" height="600" />
      <location x="200" y="200" />
      <title>$manualtitle</title>
      <toolbar>
         <helpaction image="homeIcon">javax.help.HomeAction</helpaction>
         <helpaction image="backIcon">javax.help.BackAction</helpaction>
         <helpaction image="forwardIcon">javax.help.ForwardAction</helpaction>
      </toolbar>
      <image>appIcon</image>
   </presentation>
   <!-- secondary window -->
   <presentation displayviews=false>
      <name>secondary window</name>
      <size width="450" height="500" />
      <location x="200" y="200" />
      <image>appIcon</image>
   </presentation>
   <!-- implementation section -->
   <impl>
      <helpsetregistry helpbrokerclass="javax.help.DefaultHelpBroker" />
      <viewerregistry viewertype="text/html"
         viewerclass="com.sun.java.help.impl.CustomKit"/>
      <viewerregistry viewertype="text/xml"
          viewerclass="com.sun.java.help.impl.CustomXMLKit" />
   </impl>
</helpset>
_END_HS_HEAD

close $hsfd;

my $htmlfd;

open $htmlfd, ">$helpsetdir/$base.html"
  or die "Can't open '$helpsetdir/$base.html' $!\n";
binmode($htmlfd, ":$encoding_file");

print $htmlfd &html_head($docinfo{Title}, '', $nodes[0]->{Tag});

print $htmlfd "<body>\n";

print $htmlfd "<div class=\"title\" \"><p>",
   $docinfo{Title}, "</p>\n";

print $htmlfd "<p>$docinfo{Author}</p>\n" if ($docinfo{Author});

print $htmlfd "</div><div class=\"date\">";

print $htmlfd "<p>$docinfo{Date}</p>\n" if ($docinfo{Date});

print $htmlfd "</div>";

if ($docinfo{Boilerplate})
{
   print $htmlfd '<div class="boilerplate">';
   print $htmlfd $docinfo{Boilerplate};
   print $htmlfd '</div>';
}

print $htmlfd &html_nav('', $nodes[0]);

print $htmlfd "</body>\n</html>\n";

close $htmlfd;

my $prev = $base;

my $tocfd;
open $tocfd, ">$helpsetdir/${base}TOC.xml" 
   or die "Can't open '$helpsetdir/${base}TOC.xml' $!\n";
binmode($tocfd, ":$encoding_file");

print $tocfd <<_END_TOC_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
   <!DOCTYPE toc
     PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp TOC Version
2.0//EN"
     "http://java.sun.com/products/javahelp/toc_2_0.dtd">

<toc version="2.0" xml:lang="en">
<tocitem text="Manual" target="top" >
_END_TOC_HEAD

my $prevlevel = 0;

for (my $idx = 0; $idx <= $#nodes; $idx++)
{
   my $node = $nodes[$idx];

   for (my $level = scalar(keys %section_levels); $level >= 0; $level--)
   {
      if ($section_levels{$node->{Type}}+$level <= $prevlevel)
      {
         print $tocfd "</tocitem>\n";
      }
   }

   print $tocfd "<tocitem text=\"$node->{Title}\" target=\"$node->{Tag}\">\n";

   my $next = ($idx == $#nodes ? '' : $nodes[$idx+1]);

   my $tag = $node->{Tag};

   open $htmlfd, ">$helpsetdir/$tag.html"
     or die "Can't open '$helpsetdir/$tag.html' $!\n";

   binmode($htmlfd, ":$encoding_file");

   print $htmlfd &html_head($node->{Title}, 
     ($prev eq $base ? $base : $prev->{Tag}),
     ($next ? $next->{Tag} : ''));

   print $htmlfd "<body>\n";

   my $header = 'h'.$section_levels{$node->{Type}};

   print $htmlfd "<$header>", $node->{Title}, "</$header>\n";

   my $content = $node->{Contents};

   $content=~s/<ref>([^<]+)<\/ref>/&get_ref($1)/eg;

   print $htmlfd "<div>$content</div>";

   if ($node->{Footnotes})
   {
      $content = $node->{Footnotes};

      $content=~s/<ref>([^<]+)<\/ref>/&get_ref($1)/eg;

      print $htmlfd "<hr />$content";
   }

   print $htmlfd &html_nav($prev, $next);

   print $htmlfd "</body>\n</html>\n";

   close $htmlfd;

   $prev = $node;
   $prevlevel = $section_levels{$node->{Type}};
}

for (my $level = scalar(keys %section_levels); $level >= 0; $level--)
{
   if ($level < $prevlevel)
   {
      print $tocfd "</tocitem>\n";
   }
}

print $tocfd "</tocitem>\n</toc>\n";

close $tocfd;

# write map file

my $mapfd;
open $mapfd, ">$helpsetdir/Map.jhm"
  or die "Can't open '$helpsetdir/Map.jhm' $!\n";
binmode($mapfd, ":$encoding_file");

print $mapfd <<_END_MAP_HEAD;
<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE map
 PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp Map Version 2.0//EN"
     "http://java.sun.com/products/javahelp/map_2_0.dtd">
<map version="2.0" xml:lang="$locale">
_END_MAP_HEAD

print $mapfd "<mapID target=\"top\" url=\"$base.html\" />\n";
print $mapfd "<mapID target=\"appIcon\" url=\"../../icons/flowframtklogosmall.png\" />\n";
print $mapfd "<mapID target=\"homeIcon\" url=\"../../icons/home.png\" />\n";
print $mapfd "<mapID target=\"backIcon\" url=\"../../icons/back.png\" />\n";
print $mapfd "<mapID target=\"forwardIcon\" url=\"../../icons/forward.png\" />\n";

&hs_map_id(\%tags);
&hs_map_id(\%terms);

print $mapfd "</map>\n";
close $mapfd;

# Write the helpset index file

my $idxfd;
open $idxfd, ">$helpsetdir/${base}Index.xml"
 or die "Can't open '$helpsetdir/${base}Index.xml' $!\n";
binmode($idxfd, ":$encoding_file");

print $idxfd <<_END_IDX_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
   <!DOCTYPE index
     PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp Index Version 2.0//EN"
     "http://java.sun.com/products/javahelp/index_2_0.dtd">

<index version="2.0">
_END_IDX_HEAD

&print_idx_entries(\%terms);

print $idxfd "</index>\n";
close $idxfd;

sub print_idx_entries{
   my ($hash) = @_;

   foreach my $key (keys %$hash)
   {
      if ($hash->{$key}->{Text})
      {
         my $text = $hash->{$key}->{Text};

         $text=~s/<\/?[^>]*>//g;

         print $idxfd "<indexitem text=\"",
           $text, "\" target=\"",
           $key, "\">\n";

         if ($hash->{$key}->{Children})
         {
            &print_idx_entries($hash->{$key}->{Children});
         }

         print $idxfd "</indexitem>\n";
      }
      else
      {
         warn "Text not set for '$key'.\n";
      }
   }
}

sub handle_char{
   my( $expat, $string ) = @_;

   &handle_html($string);
   &handle_tex($string);
}

sub hs_map_id{
   my ($hash) = @_;

   foreach my $tag (keys %$hash)
   {
      if ($hash->{$tag}->{Ref})
      {
         print $mapfd "<mapID target=\"$tag\" url=\"$hash->{$tag}->{Ref}\" />\n";
      }
      else
      {
         warn "No Ref found for '$tag'\n";
      }

      if ($hash->{$tag}->{Children})
      {
         &hs_map_id($hash->{$tag}->{Children});
      }
   }
}

sub firstofone{
   return shift;
}

sub cs_fmt{
   my $csname = shift ;
   return "<code>\\$csname</code>";
}

sub handle_semantic_term{
   my ($tagfield, $type, $htmlfnhandler, $expat, %attrs) = @_;

   unless ($attrs{$tagfield})
   {
      die "Missing '$type' element's '$tagfield' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &$htmlfnhandler($attrs{$tagfield});

   unless ($text=~/^</)
   {
      $text = "<span class=\"$type\">" . $text . "</span>";
   }

   &check_boolean_attribute_value('index', $expat, \%attrs);

   if (defined($attrs{index}) and not $attrs{index})
   {
      &handle_tex("\\${type}noindex{", $attrs{$tagfield}, '}');
      &handle_html($text);
   }
   else
   {
      &handle_tex("\\$type\{", $attrs{$tagfield}, '}');
      &hs_index_term($type.'_'.$attrs{$tagfield}, $text, $attrs{$tagfield}, \%terms);
   }
}

sub hs_index_term{
   my ($tag, $text, $term, $hash) = @_;

   if (defined($hash->{$tag}->{Ref}) or $#nodes < 0)
   {
      &handle_html($text);
   }
   else
   {
      $hash->{$tag}->{Ref}  = $nodes[$#nodes]->{Tag}.".html#$tag";

      &handle_html("<a name=\"$tag\">$text</a>");
   }

   $hash->{$tag}->{Text} = $term;

   unless (defined($bibentries{$tag}))
   {
      my $tex_name = $term;
      my $tex_text = $term;

      if ($tag=~/^sty_/)
      {
         $tex_name=~s/^(.*)(\.sty)?$/\\stynoindex{$1} package/;
         $tex_text=~s/^(.*)(\.sty)?$/\\stynoindex{$1}/;
      }
      elsif ($tag=~/^cls_/)
      {
         $tex_name=~s/^(.*)(\.cls)?$/\\clsnoindex{$1} class/;
         $tex_text=~s/^(.*)(\.cls)?$/\\clsnoindex{$1}/;
      }
      elsif ($tag=~/^env_/)
      {
         $tex_name = "\\envnoindex{$tex_name} environment";
         $tex_text = "\\envnoindex{$tex_text}";
      }
      elsif ($tag=~/^(cs|cli|opt|ext)_/)
      {
         $tex_name = "\\$1noindex{$tex_name}";
         $tex_text = $tex_name;
      }

      my $bib = "\@index{$tag, name={$tex_name}, text={$tex_text}";

      if (defined($hash->{$tag}))
      {
         if ($hash->{$tag}->{Parent})
         {
            $bib .= ", parent={" . $hash->{$tag}->{Parent} . "}";
         }

         if ($hash->{$tag}->{Category})
         {
            $bib .= ", category={" . $hash->{$tag}->{Category} . "}";
         }
      }

      $bib .= "}\n";

      if ($#current > -1 and ($current[$#current]=~/^New(Term|Acro)/))
      {
         $bibpending .= $bib;
      }
      else
      {
         print $bibfd $bib;
      }

      $bibentries{$tag} = $tex_name;
   }
}

sub hs_popup{
   my ($href, $text) = @_;

   my $html = <<_END_POPUP;
  <object classid="java:com.sun.java.help.impl.JHSecondaryViewer">
    <param name="viewerStyle" value="javax.help.Popup" />
    <param name="viewerSize" value="400,200" />
    <param name="content" value="$href" />
    <param name="viewerActivator" value="javax.help.LinkLabel" />
    <param name="text" value="&#x261B;" />
    <param name="textColor" value="blue" />
  </object>
_END_POPUP

   $html.$text
}

sub handle_tex{
   my ($string) = join('', @_);

   return unless ($includetex);

   if ($#current > -1)
   {
      my $element = $current[$#current];

      if ($element eq 'NewTerm' or $element eq 'NewAcro')
      {
         print $bibfd $string;
      }
      elsif ($element eq 'Boilerplate')
      {
         print $boilerfd $string;
      }
      else
      {
         print $texfd $string;
      }
   }
   else
   {
      print $texfd $string;
   }
}

sub handle_html{
   my ($string) = @_;

   return unless ($includehtml);

   if ($#current > -1)
   {
      my $element = $current[$#current];

      $docinfo{$element} .= $string;
   }
   elsif ($#nodes > -1)
   {
      $nodes[$#nodes]->{Contents} .= $string;
   }
}
 
sub handle_start {
    my( $expat, $element, %attrs ) = @_;

    my $sub = "start_$element";
 
    if (defined(&$sub))
    {
       {
         no strict 'refs';
         &$sub($expat, %attrs);
       }
    }
    else
    {
       die "Don't know what to do with '<$element>'\n";
    }
}

sub handle_end {
    my( $expat, $element ) = @_;
 
    my $sub = "end_$element";

    if (defined(&$sub))
    {
       {
         no strict 'refs';
         &$sub($expat);
       }
    }
    else
    {
       die "Don't know what to do with '</$element>'\n";
    }
}

sub get_ref{
   my ($tag) = @_;

   unless ($tags{$tag})
   {
      die "Unknown tag '$tag'\n";
   }

   my $ref = $tags{$tag}->{Ref};
   my $text = $tags{$tag}->{Text};

   "<a href=\"$ref\">$text</a>";
}

sub get_label{
   my ($tag, $attrs, $expat) = @_;

   unless ($dict{$tag})
   {
      if (defined($dict{"manual.$tag"}))
      {
         $tag = "manual.$tag";
      }
      elsif ($expat)
      {
         die "No dictionary entry for tag '$tag' on line ",
           $expat->current_line, "\n";
      }
      else
      {
         die "No dictionary entry for tag '$tag'\n";
      }
   }

   my $text = $dict{$tag};

   if ($attrs)
   {
      $text=~s/<ARG#(\d)\/>/$attrs->{"arg$1"}/eg;
   }

   $text
}

sub start_manual{
   my ($expat, %attrs) = @_;

   if ($attrs{fontenc})
   {
      $fontenc = $attrs{'fontenc'};
   }

   print $texfd "% arara: pdflatex\n";
   print $texfd "% arara: bib2gls: { group: on, trimfields: on }\n";
   print $texfd "% arara: pdflatex\n";
   print $texfd "% arara: pdflatex\n";
   print $texfd "\\documentclass[$babel{$locale}]{flowframtk}\n";
}

sub end_manual{
   my ($expat) = @_;
}

sub start_preamble{
   my ($expat, %attrs) = @_;

   print $texfd <<EOF;
\\usepackage[$inputenc]{inputenc}
\\usepackage[$fontenc]{fontenc}
\\usepackage{lmodern}
\\usepackage{graphicx}
\\usepackage{verbatim}
\\usepackage{alltt}
\\usepackage{moreverb}
\\usepackage{keystroke}
\\usepackage{babel}
\\usepackage[colorlinks]{hyperref}
\\usepackage[record=nameref]{glossaries-extra}
\\usepackage{glossaries-prefix}
$languagedefinitions

\\glsxtrnewgls{cli_}{\\cli}
\\glsxtrnewgls{sty_}{\\sty}
\\glsxtrnewgls{cls_}{\\cls}
\\glsxtrnewgls{env_}{\\env}
\\glsxtrnewgls{ext_}{\\ext}
\\glsxtrnewgls{opt_}{\\opt}

\\providecommand{\\applink}[1]{\\href{$downloadurl/#1}{#1}}
\\csname preresourcehook\\endcsname
\\GlsXtrLoadResources[src={$bibfile}]
EOF
}
 
sub end_preamble{
   my ($expat) = @_;
}

sub start_htmlonly{
   my ($expat, %attrs) = @_;

   unless ($includetex)
   {
      die "Nested <htmlonly> forbidden on line ",
           $expat->current_line, "\n";
   }

   $includetex = 0;
}

sub end_htmlonly{
   my ($expat) = @_;

   $includetex = 1;
}

sub start_latexonly{
   my ($expat, %attrs) = @_;

   unless ($includehtml)
   {
      die "Nested <latexonly> forbidden on line ",
           $expat->current_line, "\n";
   }

   $includehtml = 0;
}

sub end_latexonly{
   my ($expat) = @_;

   $includehtml = 1;
}

sub start_title{
   my ($expat, %attrs) = @_;

   push @current, 'Title';

   print $texfd "\\title{";
}

sub end_title{
   my ($expat) = @_;

   pop @current;

   print $texfd "}\n";
}

sub start_date{
   my ($expat, %attrs) = @_;

   push @current, 'Date';

   print $texfd "\\date{";
}

sub end_date{
   my ($expat) = @_;

   pop @current;

   print $texfd "}\n";
}

sub start_author{
   my ($expat, %attrs) = @_;

   push @current, 'Author';

   unless ($docinfo{Author})
   {
      $docinfo{Author} = " ";
   }

   $docinfo{Author} .= "<table class=\"author\"><tr><td>";

   print $texfd "\\Author{";
}

sub end_author{
   my ($expat) = @_;

   $docinfo{Author} .= "</td></tr></table>";

   pop @current;

   print $texfd "}\n";
}

sub start_document{
   my ($expat, %attrs) = @_;

   print $texfd "\\begin{document}\n\\maketitle\n\n";

   if ($boilerplate)
   {
      print $texfd "\\input{$boilerplatefile}\n";
   }
}

sub end_document{
   my ($expat) = @_;

   print $texfd "\\end{document}\n";
}

sub start_tableofcontents{
   my ($expat, %attrs) = @_;

   &handle_tex("\\tableofcontents\n");
}

sub end_tableofcontents{
   my ($expat, %attrs) = @_;
}

sub start_listoffigures{
   my ($expat, %attrs) = @_;

   &handle_tex("\\listoffigures\n");
}

sub end_listoffigures{
   my ($expat, %attrs) = @_;
}

sub start_listoftables{
   my ($expat, %attrs) = @_;

   &handle_tex("\\listoftables\n");
}

sub end_listoftables{
   my ($expat, %attrs) = @_;
}

sub start_node{
   my ($expat, %attrs) = @_;

   unless ($attrs{type})
   {
      die "Missing 'type' attribute for element 'node' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{tag})
   {
      die "Missing 'tag' attribute for element 'node' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{title})
   {
      die "Missing 'title' attribute for element 'node' on line ",
         $expat->current_line, "\n";
   }

   my $currentlevel = $section_levels{$attrs{type}};

   unless ($currentlevel)
   {
      die "Unknown section level '$attrs{type}' on line ",
         $expat->current_line, "\n";
   }

   my $lastlevel;

   if ($#nodes == -1)
   {
      $lastlevel = 0;
   }
   else
   {
      $lastlevel = $section_levels{$nodes[$#nodes]->{Type}};
   }

   unless ($currentlevel <= $lastlevel+1)
   {
      die "Node '$attrs{tag}' type can't be deeper than '",
        $section_levels{$lastlevel+1},"' on line ",
        $expat->current_line, "\n";
   }

   my $nodetitle = $attrs{title};

   $nodetitle=~s/\|dict (.+?)\|/&eval_dict_attrs($expat, $1, $2)/eg;

   my $htmltitle = $nodetitle;

   $htmltitle=~s/\|cs ([a-zA-Z]+)\|/<tt>\\$1<\/tt>/g;
   $htmltitle=~s/\|sty (.+?)\|/<tt>$1<\/tt>/g;

   my %node = 
   (
      Type      => $attrs{type},
      Title     => $htmltitle,
      Tag       => $attrs{tag},
      Contents  => '',
      Footnotes => '' 
   );

   push @nodes, \%node;

   $tags{$attrs{tag}}->{Ref} = $attrs{tag}.'.html';
   $tags{$attrs{tag}}->{Text} = $htmltitle;

   my $textitle = $nodetitle;
   $textitle=~s/\|(cs|sty) ([a-zA-Z]+)\|/\\$1noindex{$2}/g;

   $textitle=~s/((?:La)TeX)/\\protect\\$1\{\}/g;

   print $texfd "\\", $attrs{type}, "{$textitle}\\label{",
      $attrs{tag}, "}\n";
}

sub end_node{
   my ($expat) = @_;

}

sub start_newacro{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'tag' attribute for element 'newacro' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{short})
   {
      die "Missing 'short' attribute for element 'newacro' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{long})
   {
      die "Missing 'long' attribute for element 'newacro' on line ",
         $expat->current_line, "\n";
   }

   my $tag = $attrs{tag};

   if ($acros{$tag})
   {
      die "Acronym '$tag' already defined\n";
   }

   $acros{$tag}->{Short} = $attrs{short};
   $acros{$tag}->{Long} = $attrs{long};
   $acros{$tag}->{Prefix} = $attrs{prefix};
   $acros{$tag}->{PrefixFirst} = $attrs{prefixfirst};
   $acros{$tag}->{PrefixPlural} = $attrs{prefixplural};
   $acros{$tag}->{PrefixFirstPlural} = $attrs{prefixfirstplural};

   push @current, 'NewAcro';
   $currenttag = $tag;

   $docinfo{'NewAcro'}='';
   $bibpending = '';

   $bibentries{$currenttag} = $acros{$tag}->{Long};

   &handle_tex("\@abbreviation{$currenttag,\n short={" . $acros{$tag}->{Short}
     . "},\n long={" . $acros{$tag}->{Long} . "}");

   if ($acros{$tag}->{Prefix})
   {
      my $prefix = $acros{$tag}->{Prefix};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefix={$prefix}");

      $acros{$tag}->{Prefix}=~s/~/ /g;
   }

   if ($acros{$tag}->{PrefixFirst})
   {
      my $prefix = $acros{$tag}->{PrefixFirst};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefixfirst={$prefix}");

      $acros{$tag}->{PrefixFirst}=~s/~/ /g;
   }

   if ($acros{$tag}->{PrefixPlural})
   {
      my $prefix = $acros{$tag}->{PrefixPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefixplural={$prefix}");

      $acros{$tag}->{PrefixPlural}=~s/~/ /g;
   }

   if ($acros{$tag}->{PrefixFirstPlural})
   {
      my $prefix = $acros{$tag}->{PrefixFirstPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefixfirstplural={$prefix}");

      $acros{$tag}->{PrefixFirstPlural}=~s/~/ /g;
   }

   &handle_tex(",\n description={");
}

sub end_newacro{
   my ($expat) = @_;

   my $tag = $currenttag;

   # write html file used by popup window

   open $fd, ">$helpsetdir/acr_$tag.html" 
      or die "Can't open '$helpsetdir/acr_$tag.html' $!\n";

   print $fd &html_head($acros{$tag}->{Short});

   print $fd "<body>\n<h1>$acros{$tag}->{Short}</h1>\n",
      ucfirst($acros{$tag}->{Long}), ".\n";

   if ($docinfo{NewAcro})
   {
      $acros{$tag}->{Description} = $docinfo{NewAcro};

      print $fd "<p>", $acros{$tag}->{Description}, "</p>\n";
   }

   print $fd "</body>\n</html>\n";

   close $fd;

   &handle_tex("}\n}\n");

   pop @current;
   $currenttag = '';

   print $bibfd $bibpending;
}
 
sub start_newterm{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'tag' attribute for element 'newterm' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{text})
   {
      $attrs{text} = $attrs{tag};
   }

   $currenttag = $attrs{tag};
   my $tag = 'gls_'.$attrs{tag};

   if ($terms{$tag})
   {
      die "Term '", $attrs{tag}, "' already defined\n";
   }

   $terms{$tag}->{Text} = $attrs{text};

   push @current, 'NewTerm';
   $docinfo{'NewTerm'}='';
   $bibpending = '';

   &handle_tex("\@index{$currenttag,\n name={" . $terms{$tag}->{Text} . "},");

   $bibentries{$currenttag} = $terms{$tag}->{Text};

   if (defined($attrs{plural}))
   {
      $terms{$tag}->{Plural} = $attrs{plural};
      &handle_tex("\n plural={", $attrs{plural}, "},");
   }

   if (defined($attrs{seealso}))
   {
      $terms{$tag}->{SeeAlso} = $attrs{seealso};
      &handle_tex("\n seealso={", $attrs{seealso}, "},");
   }

   if (defined($attrs{see}))
   {
      $terms{$tag}->{See} = $attrs{see};
      &handle_tex("\n see={", $attrs{see}, "},");
   }

   if (defined($attrs{alias}))
   {
      $terms{$tag}->{Alias} = $attrs{alias};
      &handle_tex("\n alias={", $attrs{alias}, "},");
   }

   if (defined($attrs{prefix}))
   {
      $terms{$tag}->{Prefix} = $attrs{prefix};
      my $prefix = $terms{$tag}->{Prefix};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefix={$prefix},");

      $terms{$tag}->{Prefix}=~s/~/ /g;
   }

   if (defined($attrs{prefixfirst}))
   {
      $terms{$tag}->{PrefixFirst} = $attrs{prefixfirst};
      my $prefix = $terms{$tag}->{PrefixFirst};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefixfirst={$prefix},");

      $terms{$tag}->{PrefixFirst}=~s/~/ /g;
   }

   if (defined($attrs{prefixplural}))
   {
      $terms{$tag}->{PrefixPlural} = $attrs{prefixplural};
      my $prefix = $terms{$tag}->{PrefixPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefixplural={$prefix},");

      $terms{$tag}->{PrefixPlural}=~s/~/ /g;
   }

   if (defined($attrs{prefixfirstplural}))
   {
      $terms{$tag}->{PrefixFirstPlural} = $attrs{prefixfirstplural};
      my $prefix = $terms{$tag}->{PrefixFirstPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefixfirstplural={$prefix},");

      $terms{$tag}->{PrefixFirstPlural}=~s/~/ /g;
   }

   &handle_tex("\n description={");
}

sub end_newterm{
   my ($expat) = @_;

   if ($docinfo{NewTerm})
   {
      my $tag = 'gls_'.$currenttag;
      $terms{$tag}->{Description} = $docinfo{NewTerm};

      # write html file used by popup window if a description has been
      # supplied

      open $fd, ">$helpsetdir/$tag.html" 
         or die "Can't open '$helpsetdir/$tag.html' $!\n";

      print $fd &html_head($terms{$tag}->{Text});

      print $fd "<body>\n<h1>", $terms{$tag}->{Text}, "</h1>\n",
         ucfirst($terms{$tag}->{Description}), ".\n";

      print $fd "</body>\n</html>\n";

      close $fd;

   }

   &handle_tex("}}\n");

   pop @current;

   $currenttag = '';

   print $bibfd $bibpending;
}

sub check_boolean_attribute_value{
   my ($attr_name, $expat, $attrs) = @_;

   if ($attrs->{$attr_name})
   {
      my $value = lc($attrs->{$attr_name});

      if ($value eq 'true' or $value eq 1)
      {
         $value = 1;
      }
      elsif ($value eq 'false' or $value eq 0)
      {
         $value = 0;
      }
      else
      {
         die "Invalid value '$value' of attribute 'short' on line ",
           $expat->current_line, "\n";
      }

      $attrs->{$attr_name} = $value;
   }
}
 
sub start_frontmatter{
   my ($expat, %attrs) = @_;

   &handle_tex('\\frontmatter ');
}

sub end_frontmatter{
   my ($expat) = @_;
}

sub start_mainmatter{
   my ($expat, %attrs) = @_;

   &handle_tex('\\mainmatter ');
}

sub end_mainmatter{
   my ($expat) = @_;
}

sub start_backmatter{
   my ($expat, %attrs) = @_;

   &handle_tex('\\backmatter ');
}

sub end_backmatter{
   my ($expat) = @_;
}

sub start_boilerplate{
   my ($expat, %attrs) = @_;

   open $boilerfd, ">$boilerplatefile"
     or die "Can't open boilerplate file '$boilerplatefile' $!\n";

   push @current, 'Boilerplate';
   &handle_tex('\\begin{boilerplate}');
}

sub end_boilerplate{
   my ($expat) = @_;
   &handle_tex('\\end{boilerplate}');
   pop @current;

   $boilerplate = 1;
   close $boilerfd;
}

sub start_p{
   my ($expat, %attrs) = @_;

   my $endtag="\n\n";

   &check_boolean_attribute_value('short', $expat, \%attrs);
   &check_boolean_attribute_value('indent', $expat, \%attrs);

   if ($attrs{'short'})
   {
      $endtag='\\glspar ';
   }

   &handle_html("<p");

   if ($attrs{class})
   {
      if ($attrs{class} eq 'warning')
      {
         &handle_tex('\\warning ');
      }
      elsif ($attrs{class}=~/^(tex|pgf|flf)$/)
      {
         &handle_tex('\\' . $attrs{class} . 'related ');
      }
      else
      {
         warn("Unknown paragraph class '" . $attrs{class} . '"');
      }

      &handle_html(' class="' . $attrs{class} . '"');
   }

   if ($attrs{align})
   {
      &handle_html(' align="'.$attrs{'align'}.'">');

      if ($attrs{align} eq 'left')
      {
         &handle_tex("\\begin{flushleft}");
         $endtag="\\end{flushleft}";
      }
      elsif ($attrs{align} eq 'right')
      {
         &handle_tex("\\begin{flushright}");
         $endtag="\\end{flushright}";
      }
      elsif ($attrs{align} eq 'center')
      {
         &handle_tex("\\begin{center}");
         $endtag="\\end{center}";
      }
      else
      {
         die "Unknown alignment option", $attrs{align},
          " for 'p' element on line ", $expat->current_line, "\n";
      }
   }
   else
   {
      &handle_html(">");
      &handle_tex($endtag);

      &handle_tex("\\noindent ") if $attrs{noindent};
   }

   push @paragraph, $endtag;
}

sub end_p{
   my ($expat) = @_;

   &handle_html("</p>");

   &handle_tex(pop @paragraph);
}

sub start_dl{
   my ($expat, %attrs) = @_;

   &handle_html("<dl>");

   &handle_tex("\\begin{description}");
}

sub end_dl{
   my ($expat) = @_;

   &handle_html("</dl>");

   &handle_tex("\\end{description}");
}

sub start_ul{
   my ($expat, %attrs) = @_;

   &handle_html("<ul>");

   &handle_tex("\\begin{itemize}");
}

sub end_ul{
   my ($expat) = @_;

   &handle_html("</ul>");

   &handle_tex("\\end{itemize}");
}

sub start_tt{
   my ($expat, %attrs) = @_;

   &handle_html("<tt>");

   &handle_tex("\\texttt{");
}

sub end_tt{
   my ($expat) = @_;

   &handle_html('</tt>');

   &handle_tex("}");
}

sub start_b{
   my ($expat, %attrs) = @_;

   &handle_html("<b>");

   &handle_tex("\\textbf{");
}

sub end_b{
   my ($expat) = @_;

   &handle_html('</b>');

   &handle_tex("}");
}

sub start_em{
   my ($expat, %attrs) = @_;

   &handle_html("<em>");

   &handle_tex("\\emph{");
}

sub end_em{
   my ($expat) = @_;

   &handle_html('</em>');

   &handle_tex("}");
}

sub start_kbd{
   my ($expat, %attrs) = @_;

   unless ($attrs{key})
   {
      die "element 'kbd' missing 'key' attribute\n";
   }

   my $key = ucfirst($attrs{key});

   if ($key eq 'Space')
   {
      &handle_tex("\\Spacebar{}");
      &handle_html("<kbd>Space Bar</kbd>");
   }
   elsif ($key eq 'Return')
   {
      &handle_tex("\\Return{}");
      &handle_html("<kbd>Return &#x23CE;</kbd>");
   }
   elsif ($key eq 'Backspace')
   {
      &handle_tex("\\BSpace{}");
      &handle_html("<kbd>Backspace &#x21A4;</kbd>");
   }
   elsif ($key eq 'Tab')
   {
      &handle_tex("\\Tab{}");
      &handle_html("<kbd>Tab &#x21B9;</kbd>");
   }
   elsif ($key eq 'Pageup')
   {
      &handle_tex("\\PgUp{}");
      &handle_html("<kbd>PgUp &#x2191;</kbd>");
   }
   elsif ($key eq 'Pagedown')
   {
      &handle_tex("\\PgDown{}");
      &handle_html("<kbd>PgDn &#x2193;</kbd>");
   }
   elsif ($key eq 'Shift')
   {
      &handle_tex("\\Shift{}");
      &handle_html("<kbd>Shift &#x21D1;</kbd>");
   }
   elsif ($key eq 'Up')
   {
      &handle_tex("\\UArrow{}");
      &handle_html("<kbd>&#x2191;</kbd>");
   }
   elsif ($key eq 'Down')
   {
      &handle_tex("\\DArrow{}");
      &handle_html("<kbd>&#x2193;</kbd>");
   }
   elsif ($key eq 'Left')
   {
      &handle_tex("\\LArrow{}");
      &handle_html("<kbd>&#x2190;</kbd>");
   }
   elsif ($key eq 'Right')
   {
      &handle_tex("\\RArrow{}");
      &handle_html("<kbd>&#x2192;</kbd>");
   }
   elsif ($key eq 'Altgr')
   {
      &handle_tex("\\AltGr{}");
      &handle_html("<kbd>AltGr</kbd>");
   }
   elsif ($key eq 'PrtSc')
   {
      &handle_tex("\\PrtSc{}");
      &handle_html("<kbd>PrtSc</kbd>");
   }
   else
   {
      &handle_tex("\\keystroke{$key}");
      &handle_html("<kbd>$key</kbd>");
   }
}

sub end_kbd{
   my ($expat) = @_;

}

sub start_file{
   my ($expat, %attrs) = @_;

   &handle_html("<tt>");

   &handle_tex("\\file{");
}

sub end_file{
   my ($expat) = @_;

   &handle_html('</tt>');

   &handle_tex("}");
}

sub start_li{
   my ($expat, %attrs) = @_;

   &handle_html("<li>");

   &handle_tex("\\item ");
}

sub end_li{
   my ($expat) = @_;

   &handle_html("</li>");
}


sub start_dt{
   my ($expat, %attrs) = @_;

   &handle_html("<dt>");

   &handle_tex("\\item[{");
}

sub end_dt{
   my ($expat) = @_;

   &handle_html("</dt>");

   &handle_tex("}]");
}

sub start_dd{
   my ($expat, %attrs) = @_;

   &handle_html("<dd>");

}

sub end_dd{
   my ($expat) = @_;

   &handle_html("</dd>");

}

sub start_meta{
   my ($expat, %attrs) = @_;

   &handle_html("&#x27E8;<em>");

   &handle_tex("\\meta{");
}

sub end_meta{
   my ($expat) = @_;

   &handle_html('</em>&#x27E9;');

   &handle_tex("}");
}

sub start_marg{
   my ($expat, %attrs) = @_;

   &handle_html('{');

   &handle_tex("\\marg{");
}

sub end_marg{
   my ($expat) = @_;

   &handle_html('}');

   &handle_tex("}");
}

sub start_dq{
   my ($expat, %attrs) = @_;

   &handle_html('"');

   &handle_tex("\\dq{");
}

sub end_dq{
   my ($expat) = @_;

   &handle_html('"');

   &handle_tex("}");
}

sub start_url{
   my ($expat, %attrs) = @_;

   unless ($attrs{www})
   {
      die "element 'url' missing 'www' attribute\n";
   }

   my $string;

   my $uri = $attrs{www};

   $uri = "http://$uri" unless ($uri=~/^[a-z]+:\/\//);

   if ($attrs{text})
   {
      &handle_tex("\\href{", $attrs{www}, "}{", $attrs{text}, "}");
      $string = "<a href=\"$uri\">$attrs{text}</a>";
   }
   else
   {
      &handle_tex("\\url{", $attrs{www}, "}");
      $string = "<a href=\"$uri\"><tt>$attrs{www}</tt></a>";
   }

   &handle_html($string);
}

sub end_url{
   my ($expat) = @_;
}

sub start_sty{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'sty', \&firstofone, $expat, %attrs);
}

sub end_sty{
   my ($expat) = @_;
}

sub start_cli{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'cli', \&firstofone, $expat, %attrs);
}

sub end_cli{
   my ($expat) = @_;
}

sub start_ext{
   my ($expat, %attrs) = @_;

   unless ($attrs{name})
   {
      die "Missing 'ext' element's 'name' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = $attrs{name};

   unless ($terms{fileextensions})
   {
      &hs_index_term('fileextensions', '', &get_label('manual.file.extensions'), \%terms);

      my %hash = ();

      $terms{fileextensions}->{Children} = \%hash;
   }

   my $tag = 'ext_'.$attrs{name};

   $terms{fileextensions}->{Children}->{$tag}->{Parent} = 'fileextensions';

   &hs_index_term($tag, "<span class=\"ext\">.$text</span>", $text, 
      $terms{fileextensions}->{Children});

   &handle_tex("\\ext{", $attrs{name}, "}");
}

sub end_ext{
   my ($expat) = @_;
}

sub start_footnote{
   my ($expat, %attrs) = @_;

   if ($counters{footnote})
   {
      $counters{footnote} = 1;
   }
   else
   {
      $counters{footnote}++;
   }

   $nodes[$#nodes]->{Contents} .=
     "<sup><a href=\"#fn-$counters{footnote}\">$counters{footnote}</a></sup>";

   push @current, 'Footnote';

   &handle_tex("\\footnote{");
}

sub end_footnote{
   my ($expat) = @_;

   pop @current;

   $nodes[$#nodes]->{Footnotes} .=
     "<p><sup><a name=\"fn-$counters{footnote}\">$counters{footnote}</a></sup>"
     . $docinfo{Footnote}
     . '</p>';

   $docinfo{Footnote} = '';

   &handle_tex("}");
}

sub start_example{
   my ($expat, %attrs) = @_;

   if ($counters{example})
   {
      $counters{example}++;
   }
   else
   {
      $counters{example} = 1;
   }

   &handle_html('<blockquote><p><b>'
    . &get_label('manual.example')
    . '&nbsp;' . $counters{example}
    . ($attrs{title}? "($attrs{title})." : '.')
    . '</b></p>');

   &handle_tex("\\begin{example}");

   if ($attrs{title})
   {
      &handle_tex('[', $attrs{title}, ']');
   }
}

sub end_example{
   my ($expat) = @_;

   &handle_html('</blockquote>');

   &handle_tex("\\end{example}");
}

sub start_seealso{
   my ($expat, %attrs) = @_;

   unless ($attrs{tags})
   {
      die "Element 'seealso' missing 'tags' attribute on line ",
        $expat->current_line, "\n";
   }

   my @tags = split /,/, $attrs{tags};

   my $seealso = &get_label('manual.seealso');

   &handle_html("<p>$seealso<ul>");

   &handle_tex("\n\n\\minisec{$seealso}\n");

   &handle_tex("\\begin{itemize}\n");

   foreach my $tag (@tags)
   {
      &handle_html("<li><ref>$tag</ref>");
      &handle_tex("\\item \\nameref{$tag}\n");
   }

   &handle_tex("\\end{itemize}\n");

   &handle_html('</ul>');
}

sub end_seealso{
   my ($expat) = @_;
}

sub start_pre{
   my ($expat, %attrs) = @_;

   &handle_html('<pre>');

   &handle_tex("\\begin{verbatim}");
}

sub end_pre{
   my ($expat) = @_;

   &handle_html('</pre>');

   &handle_tex("\\end{verbatim}");
}

sub start_alltt{
   my ($expat, %attrs) = @_;

   &handle_html('<pre>');

   &handle_tex("\\begin{alltt}");
}

sub end_alltt{
   my ($expat) = @_;

   &handle_html('</pre>');

   &handle_tex("\\end{alltt}");
}

sub start_verb{
   my ($expat, %attrs) = @_;

   &handle_html('<pre style="display: inline;">');

   &handle_tex("\\verb|");
}

sub end_verb{
   my ($expat) = @_;

   &handle_html('</pre>');

   &handle_tex("|");
}

sub start_verbinput{
   my ($expat, %attrs) = @_;

   unless ($attrs{src})
   {
      die "Missing 'verbinput' element's 'src' attribute on line ",
        $expat->current_line, "\n";
   }

   &handle_html('<pre>');

   open $fd, $attrs{src} or die "Can't open verbatim file '$attrs{src}' $!\n";

   while (<$fd>)
   {
      s/\&/\&amp;/g;
      s/</\&lt;/g;
      s/>/\&gt;/g;

      &handle_html($_);
   }

   close $fd;

   &handle_html('</pre>');

   &handle_tex("\\verbatiminput{$attrs{src}}");
}

sub end_verbinput{
   my ($expat) = @_;
}
 
sub start_verbtabinput{
   my ($expat, %attrs) = @_;

   unless ($attrs{src})
   {
      die "Missing 'verbtabinput' element's 'src' attribute on line ",
        $expat->current_line, "\n";
   }

   &handle_html('<pre>');

   open $fd, $attrs{src} or die "Can't open '$attrs{src}' $!\n";

   while (<$fd>)
   {
      s/\&/\&amp;/g;
      s/</\&lt;/g;
      s/>/\&gt;/g;

      &handle_html($_);
   }

   close $fd;

   &handle_html('</pre>');

   &handle_tex("\\verbatimtabinput{$attrs{src}}");
}

sub end_verbtabinput{
   my ($expat) = @_;
}
 
sub start_float{
   my ($expat, %attrs) = @_;

   unless ($attrs{type})
   {
      die "Element 'float' missing 'type' attribute on line ",
        $expat->current_line, "\n";
   }

   unless ($attrs{tag})
   {
      die "Element 'float' missing 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   unless ($attrs{caption})
   {
      die "Element 'float' missing 'caption' attribute on line ",
        $expat->current_line, "\n";
   }

   my $pos = ($attrs{pos}? "[$attrs{pos}]" : '');

   if ($counters{$attrs{type}})
   {
      $counters{$attrs{type}}++;
   }
   else
   {
      $counters{$attrs{type}} = 1;
   }

   $attrs{counter} = $counters{$attrs{type}};

   push @float_elements, \%attrs;

   &handle_html("<div class=\"float\"><a name=\"$attrs{tag}\"></a>");

   $tags{$attrs{tag}}->{Ref} = $nodes[$#nodes]->{Tag}
     .'.html#'.$attrs{tag};
   $tags{$attrs{tag}}->{Text} = ucfirst(&get_label('manual.'.$attrs{type}))
        . '&nbsp;' . $attrs{counter};

   unless ($attrs{type} eq 'figure')
   {
      &handle_html('<p></p><p>' . $tags{$attrs{tag}}->{Text} . ': '
        . $attrs{caption} . '</p>');
   }

   &handle_tex("\\begin{", $attrs{type}, "}$pos\n", 
     "\\floatconts{", $attrs{tag}, "}{\\caption");

   if ($attrs{listcaption})
   {
      &handle_tex("[", $attrs{listcaption}, "]");
   }

   &handle_tex("{", $attrs{caption}, "}}{");
}

sub end_float{
   my ($expat) = @_;

   my $attrs = pop @float_elements;

   if ($attrs->{type} eq 'figure')
   {
      &handle_html('<p>'. $tags{$attrs->{tag}}->{Text} . ': '
        . $attrs->{caption} . '</p><p></p>');
   }

   &handle_html('</div>');

   &handle_tex("}%\n\\end{", $attrs->{type}, "}\n");
}

sub start_nbsp{
   my ($expat, %attrs) = @_;

   &handle_html('&nbsp;');

   &handle_tex("~");
}

sub end_nbsp{
   my ($expat) = @_;
}

sub start_emdash{
   my ($expat, %attrs) = @_;

   &handle_html('&#x2014;');

   &handle_tex("---");
}

sub end_emdash{
   my ($expat) = @_;
}

sub start_hash{
   my ($expat, %attrs) = @_;

   &handle_html('<code>#</code>');

   &handle_tex("\\texttt{\\#}");
}

sub end_hash{
   my ($expat) = @_;
}

sub start_tilde{
   my ($expat, %attrs) = @_;

   &handle_html('~');

   &handle_tex("\\textasciitilde ");
}

sub end_tilde{
   my ($expat) = @_;
}

sub start_lt{
   my ($expat, %attrs) = @_;

   &handle_html('&lt;');

   &handle_tex("\\textless ");
}

sub end_lt{
   my ($expat) = @_;
}

sub start_gt{
   my ($expat, %attrs) = @_;

   &handle_html('&gt;');

   &handle_tex("\\textgreater ");
}

sub end_gt{
   my ($expat) = @_;
}

sub start_element{
   my ($expat, %attrs) = @_;

   &handle_html('<code>&lt;');

   &handle_tex("\\element{");
}

sub end_element{
   my ($expat) = @_;

   &handle_html('&gt;</code>');

   &handle_tex("}");
}

sub start_image{
   my ($expat, %attrs) = @_;

   unless ($attrs{src})
   {
      die "Missing 'image' element's 'src' attribute on line ",
        $expat->current_line, "\n";
   }

   my $imgfile = $attrs{src};

   unless (-e $imgfile)
   {
      die "Can't find image file '$imgfile' referenced on line ",
         $expat->current_line, "\n";
   }

   my @opts=();

   my $html = "";

   foreach my $key (keys %attrs)
   {
      if ($key eq 'scale')
      {
         push @opts, "scale=$attrs{scale}";
      }
      elsif ($key eq 'width')
      {
         push @opts, "width=$attrs{width}";
         $html .= "$key=\"$attrs{$key}\" ";
      }
      elsif ($key eq 'height')
      {
         push @opts, "height=$attrs{height}";
         $html .= "$key=\"$attrs{$key}\" ";
      }
      else
      {
         $html .= "$key=\"$attrs{$key}\" ";
      }
   }

   if (not $attrs{width} or not $attrs{height})
   {
      # get image dimensions

      $_ = `file $imgfile`;

      if (/(\d+) x (\d+)/)
      {
         $html .= "width=\"$1\" " unless $attrs{width};
         $html .= "height=\"$2\" " unless $attrs{height};
      }
      else
      {
         warn "Can't determine dimensions of image '$imgfile'\n";
      }
   }

   $html = "<img $html />";

   &handle_html($html);

   &handle_tex("\\includegraphics[", join(',', @opts), "]{$imgfile}");
}

sub end_image{
   my ($expat) = @_;
}

sub start_LaTeX{
   my ($expat, %attrs) = @_;

   &handle_html('LaTeX');

   &handle_tex("\\LaTeX{}");
}

sub end_LaTeX{
   my ($expat) = @_;
}

sub start_TeX{
   my ($expat, %attrs) = @_;

   &handle_html('TeX');

   &handle_tex("\\TeX{}");
}

sub end_TeX{
   my ($expat) = @_;
}

sub start_relax{
   my ($expat, %attrs) = @_;

   &handle_tex("\\relax ");
}

sub end_relax{
   my ($expat) = @_;
}

sub start_app{
   my ($expat, %attrs) = @_;

   my $tag="appname";

   my $text = &get_label($tag, \%attrs, $expat);

   &handle_html("<span class=\"app\">$text</span>");

   &handle_tex("\\appfmt{$text}");
}

sub end_app{
   my ($expat) = @_;
}

sub start_appversion{
   my ($expat, %attrs) = @_;

   my $tag="appversion";

   my $text = &get_label($tag, \%attrs, $expat);

   &handle_html($text);

   &handle_tex($text);
}

sub end_appversion{
   my ($expat) = @_;
}

sub start_applink{
   my ($expat, %attrs) = @_;

   $docinfo{AppLink} = '';

   push @current, 'AppLink';

   print $texfd "\\applink{";
}

sub end_applink{
   my ($expat) = @_;

   pop @current;

   print $texfd "}\n";

   my $file = $docinfo{AppLink};

   &handle_html("<a href=\"$downloadurl/$file\" class=\"file\">$file</a>");
}

sub eval_dict_attrs{
   my ($expat, $str) = @_;
   my %attrs = ();

   while ($str=~/([a-z]+)\s*=\s*([a-z]+)/g)
   {
      $attrs{$1} = $2;
   }

   unless ($attrs{tag})
   {
      die "Missing 'dict' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &get_label($attrs{tag}, \%attrs, $expat);

   if (defined($attrs{case}))
   {
      if ($attrs{case} eq 'ucfirst')
      {
         $text = ucfirst($text);
      }
      elsif ($attrs{case} eq 'uc')
      {
         $text = uc($text);
      }
      elsif ($attrs{case} eq 'lc')
      {
         $text = lc($text);
      }
      elsif ($attrs{case} ne 'none')
      {
         die "Unknown 'case' value '", $attrs{case}, "' for 'dict' element on line ",
          $expat->current_line, "\n";
      }
   }

   return $text;
}

sub start_dict{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'dict' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &get_label($attrs{tag}, \%attrs, $expat);

   if (defined($attrs{case}))
   {
      if ($attrs{case} eq 'ucfirst')
      {
         $text = ucfirst($text);
      }
      elsif ($attrs{case} eq 'uc')
      {
         $text = uc($text);
      }
      elsif ($attrs{case} eq 'lc')
      {
         $text = lc($text);
      }
      elsif ($attrs{case} ne 'none')
      {
         die "Unknown 'case' value '", $attrs{case}, "' for 'dict' element on line ",
          $expat->current_line, "\n";
      }
   }

   &handle_html($text);

   &handle_tex($text);
}

sub end_dict{
   my ($expat) = @_;
}
 
sub start_button{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'button' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &get_label($attrs{tag}, \%attrs, $expat);

   $text=~s/:\s*$//;

   &handle_html("<b>$text</b>");

   &handle_tex("\\button{$text}");
}

sub end_button{
   my ($expat) = @_;
}
 
sub start_menu{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'menu' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $hash = \%terms;

   my $currentlabel;
   my $html  = '';
   my $parent = '';

   foreach my $item (split /\./, $attrs{tag})
   {
      if ($currentlabel)
      {
         $currentlabel .= ".$item";
         &handle_tex("\\mto ");
         $html .= '&#x279C;';
      }
      else
      {
         $currentlabel = $item;
      }

      my $text = &get_label($currentlabel, \%attrs, $expat);

      $html .= $text;

      &handle_tex("\\menu{$text}");

      my $termtag = 'menu_'.$currentlabel;

      if ($parent)
      {
         $hash->{$termtag}->{Parent} = $parent;
      }

      &hs_index_term($termtag, "", $text, $hash);

      unless ($hash->{$termtag}->{Children})
      {
         my %h = ();
         $hash->{$termtag}->{Children} = \%h;
      }

      $hash = $hash->{$termtag}->{Children};

      $parent = $termtag;
   }

   &handle_html("<span class=\"menu\">$html</span>");

   &handle_tex("\\glsadd{$attrs{tag}");
}

sub end_menu{
   my ($expat) = @_;
}
 
sub start_acr{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'acr' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   unless ($acros{$attrs{tag}})
   {
      die "Unknown acronym tag '$attrs{tag}' on line ",
         $expat->current_line, "\n";
   }

   &check_boolean_attribute_value('prefix', $expat, \%attrs);
   &check_boolean_attribute_value('plural', $expat, \%attrs);

   if (!defined($attrs{'case'}))
   {
      $attrs{'case'} = 'none';
   }

   unless ($attrs{'case'}=~/^none|uc(first)?$/)
   {
      die "Unknown case value '", $attrs{'case'}, "' for acr '",
       $attrs{'tag'}, "' on line", $expat->current_line, "\n";
   }

   my $html = '';

   if ($acros{$attrs{tag}}->{Used} or $#nodes == -1)
   {
      if ($attrs{prefix} and $acros{$attrs{tag}}->{Prefix})
      {
         $html = $acros{$attrs{tag}}->{Prefix};
      }

      if ($attrs{plural})
      {
         $html .= $acros{$attrs{tag}}->{ShortPlural};
      }
      else
      {
         $html .= $acros{$attrs{tag}}->{Short};
      }

      if ($attrs{'case'} eq 'uc')
      {
         $html = uc($html);
      }
      elsif ($attrs{'case'} eq 'ucfirst')
      {
         $html = ucfirst($html);
      }

      &handle_html(&hs_popup("acr_".$attrs{tag}.".html", $html));
   }
   else
   {
      $acros{$attrs{tag}}->{Used} = 1;

      if ($attrs{prefix} and $acros{$attrs{tag}}->{PrefixFirst})
      {
         $html = $acros{$attrs{tag}}->{PrefixFirst};
      }

      if ($attrs{plural})
      {
         if (defined($acros{$attrs{tag}}->{LongPlural}))
         {
            $html .= $acros{$attrs{tag}}->{LongPlural};
         }
         else
         {
            $html .= $acros{$attrs{tag}}->{Long} . 's';
         }

         $html .= '(';

         if (defined($acros{$attrs{tag}}->{ShortPlural}))
         {
            $html .= $acros{$attrs{tag}}->{ShortPlural};
         }
         else
         {
            $html .= $acros{$attrs{tag}}->{Short} . 's';
         }

         $html .= ')';
      }
      else
      {
         $html .= $acros{$attrs{tag}}->{Long}
               . ' (' . $acros{$attrs{tag}}->{Short} . ')';
      }

      if ($attrs{'case'} eq 'uc')
      {
         $html = uc($html);
      }
      elsif ($attrs{'case'} eq 'ucfirst')
      {
         $html = ucfirst($html);
      }

      &hs_index_term('acr_'.$attrs{tag}, $html, ucfirst($html), \%terms);
   }

   my $csname = 'gls';

   if ($attrs{prefix})
   {
      $csname = "p$csname";
   }

   if ($attrs{'case'} eq 'uc')
   {
      $csname = uc($csname);
   }
   elsif ($attrs{'case'} eq 'ucfirst')
   {
      $csname = ucfirst($csname);
   }

   if ($attrs{plural})
   {
      $csname .= 'pl';
   }

   &handle_tex("\\", $csname, "{", $attrs{tag}, "}");
}

sub end_acr{
   my ($expat) = @_;
}
 
sub start_term{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'term' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $hstag = "gls_".$attrs{tag};

   unless ($terms{$hstag})
   {
      die "Unknown term tag '$hstag' on line ",
         $expat->current_line, "\n";
   }

   &check_boolean_attribute_value('prefix', $expat, \%attrs);
   &check_boolean_attribute_value('plural', $expat, \%attrs);

   if (!defined($attrs{'case'}))
   {
      $attrs{'case'} = 'none';
   }

   unless ($attrs{'case'}=~/^none|uc(first)?$/)
   {
      die "Unknown case value '", $attrs{'case'}, "' for term '",
       $attrs{'tag'}, "' on line", $expat->current_line, "\n";
   }

   my $html = '';

   if ($attrs{plural})
   {
      if ($attrs{prefix} and $terms{$hstag}->{PrefixPlural})
      {
         $html = $terms{$hstag}->{PrefixPlural};
      }

      if (defined($terms{$hstag}->{Plural}))
      {
         $html .= $terms{$hstag}->{Plural};
      }
      else
      {
         $html .= $terms{$hstag}->{Text} . 's';
      }
   }
   else
   {
      if ($attrs{prefix} and $terms{$hstag}->{Prefix})
      {
         $html = $terms{$hstag}->{Prefix};
      }

      $html .= $terms{$hstag}->{Text};
   }

   if ($attrs{case} eq 'uc')
   {
      $html = uc($html);
   }
   elsif ($attrs{case} eq 'ucfirst')
   {
      $html = ucfirst($html);
   }

   if (!defined($terms{$hstag}->{Ref}) and $#nodes > -1)
   {
      $terms{$hstag}->{Ref} = $nodes[$#nodes]->{Tag} . ".html#$hstag";
   }

   my $desctag = $hstag;

   if (defined($terms{$hstag}->{Alias}))
   {
      $desctag = "gls_".$terms{$hstag}->{Alias};

      unless ($terms{$desctag})
      {
         die "Unknown alias '$desctag' for term tag '$hstag' on line ",
            $expat->current_line, "\n" ;
      }
   }

   my $csname = 'gls';

   if ($attrs{prefix})
   {
      $csname = "p$csname";
   }

   if ($attrs{'case'} eq 'uc')
   {
      $csname = uc($csname);
   }
   elsif ($attrs{'case'} eq 'ucfirst')
   {
      $csname = ucfirst($csname);
   }

   if ($attrs{plural})
   {
      $csname .= 'pl';
   }

   if ($terms{$desctag}->{Description})
   {
      $html = &hs_popup("$desctag.html", $html);

      &handle_tex("\\$csname\{", $attrs{tag}, "}");
   }
   else
   {
      &handle_tex("\\$csname\{$hstag}");
   }

   &hs_index_term($hstag, $html, $terms{$hstag}->{Text}, 
     \%terms);

}

sub end_term{
   my ($expat) = @_;
}

sub start_plural{
   my ($expat, %attrs) = @_;

   $attrs{plural} = 1;
   &start_term($expat, %attrs);
}

sub end_plural{
   my ($expat) = @_;
}

sub start_ref{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'ref' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   &handle_html("<ref>$attrs{tag}</ref>");

   if ($attrs{text})
   {
      &handle_tex("\\hyperref[$attrs{tag}]{$attrs{text}}");
   }
   else
   {
      &handle_tex("\\autoref{", $attrs{tag}, "}");
   }
}

sub end_ref{
   my ($expat) = @_;
}
 
sub start_opt{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'opt' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = $attrs{tag};

   unless ($terms{options})
   {
      &hs_index_term('options', '', &get_label('manual.options'), \%terms);

      my %hash = ();

      $terms{options}->{Children} = \%hash;
   }

   my $tag = 'opt_'.$attrs{tag};

   $terms{options}->{Children}->{$tag}->{Parent} = 'options';

   &hs_index_term($tag, "<span class=\"opt\">--$text</span>", $text, 
      $terms{options}->{Children});

   &handle_tex("\\opt{", $attrs{tag}, "}");
}

sub end_opt{
   my ($expat) = @_;
}

sub start_backslash{
   my ($expat, %attrs) = @_;

   &handle_html("<code>\\</code>");

   &handle_tex("\\texttt{\\char`\\\\}");
}

sub end_backslash{
   my ($expat) = @_;
}

sub start_doublebackslash{
   my ($expat, %attrs) = @_;

   &handle_html("<code>\\\\</code>");

   &handle_tex("\\cs{\\char`\\\\}");
}

sub end_doublebackslash{
   my ($expat) = @_;
}

sub start_cs{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('tag', 'cs', \&cs_fmt, $expat, %attrs);
}

sub end_cs{
   my ($expat) = @_;
}

sub start_env{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'env', \&firstofone, $expat, %attrs);
}

sub end_env{
   my ($expat) = @_;
}

sub start_tabular{
   my ($expat, %attrs) = @_;

   unless ($attrs{spec})
   {
      die "Element 'tabular' missing 'spec' attribute on line ",
         $expat->current_line;
   }

   &handle_html('<table>');

   &handle_tex("\\begin{tabular}{", $attrs{spec}, '}');

   my %hash =
   (
      spec => $attrs{spec},
      column => 1
   );

   push @tabular_specs, \%hash;
}
 
sub end_tabular{
   my ($expat) = @_;

   &handle_html('</table>');

   pop @tabular_specs;

   &handle_tex("\\end{tabular}");
}

sub start_tr{
   my ($expat, %attrs) = @_;

   $tabular_specs[$#tabular_specs]->{column} = 1;

   &handle_html('<tr>');
}

sub end_tr{
   my ($expat) = @_;

   &handle_html('</tr>');

   &handle_tex("\\tabularnewline ");
}

sub start_td{
   my ($expat, %attrs) = @_;

   my $colspan = 1;

   if ($attrs{span})
   {
      $colspan = $attrs{span};

      unless ($colspan=~/^\d+$/)
      {
         die "Attribute 'span' must be an integer on line ",
           $expat->current_line, "\n";
      }
   }

   my $orgcolspec = substr $tabular_specs[$#tabular_specs]->{spec},
      $tabular_specs[$#tabular_specs]->{column}-1, 1;

   my $colspec = $orgcolspec;

   if ($attrs{spec})
   {
      $colspec = $attrs{spec};
   }

   my $htmlcolspan = ($colspan == 1 ? '' : "colspan=\"$colspan\"");

   if ($colspec eq 'l')
   {
      &handle_html("<td align=\"left\" $htmlcolspan>");
   }
   elsif ($colspec eq 'r')
   {
      &handle_html("<td align=\"right\" $htmlcolspan>");
   }
   elsif ($colspec eq 'c')
   {
      &handle_html("<td align=\"center\" $htmlcolspan>");
   }

   unless ($tabular_specs[$#tabular_specs]->{column} == 1)
   {
      &handle_tex("&");
   }

   if (($orgcolspec eq $colspec) and $colspan == 1)
   {
      $tabular_specs[$#tabular_specs]->{egroup} = '';
   }
   else
   {
      &handle_tex("\\multicolumn{$colspan}{$colspec}{");
      $tabular_specs[$#tabular_specs]->{egroup} = '}';
   }

   $tabular_specs[$#tabular_specs]->{column} += $colspan;
}

sub end_td{
   my ($expat) = @_;

   &handle_html('</td>');

   &handle_tex($tabular_specs[$#tabular_specs]->{egroup});
}

sub start_printglossary{
   my ($expat, %attrs) = @_;

   &handle_tex("\\printmainglossary");
}

sub end_printglossary{
   my ($expat) = @_;
}
 
sub start_printindex{
   my ($expat, %attrs) = @_;

   &handle_tex("\\printmainindex ");
}

sub end_printindex{
   my ($expat) = @_;
}
 
sub start_br{
   my ($expat, %attrs) = @_;

   &handle_html("<br />");

   &handle_tex("\\\\");
}

sub end_br{
   my ($expat) = @_;
}

sub start_hr{
   my ($expat, %attrs) = @_;

   &handle_html("<hr />");

   &handle_tex("\\hrulefill ");
}

sub end_hr{
   my ($expat) = @_;
}

sub start_cont{
   my ($expat, %attrs) = @_;

   &handle_tex("\\continueline ");
}

sub end_cont{
   my ($expat) = @_;
}

sub start_contexplan{
   my ($expat, %attrs) = @_;

  &handle_tex(&get_label('manual.cont_explanation'));
}


sub end_contexplan{
   my ($expat) = @_;
}

sub start_percent{
   my ($expat, %attrs) = @_;

   &handle_html("%");
   &handle_tex("\\%");
}

sub end_percent{
   my ($expat) = @_;
}

sub html_head{
  my ($title, $prev, $next) = @_;

  $title = 'Untitled' unless($title);

  my $head = <<_END_HTML_HEAD;
<!DOCTYPE html  html public "-//w3c//dtd xhtml 1.0 Transitional//en"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB"
xml:lang="en-GB">
<head>
  <style type="text/css">
    .title
    {
      display: inline;
      font-weight: bold;
      font-size: xx-large;
      text-align: center;
    }
    .author
    {
      display: inline;
      font-weight: bold;
      font-size: large;
      text-align: center;
      padding: 2em;
    }
    .date
    {
      display: inline;
      font-weight: bold;
      font-size: normal;
      text-align: center;
    }
    .float
    {
       text-align: center;
       padding-top: 16;
    }
    .file
    {
       font-family: monospace;
    }
    .cli
    {
       font-family: monospace;
    }
    .env
    {
       font-family: monospace;
    }
    .opt
    {
       font-family: monospace;
    }
    .menu
    {
       font-family: sans-serif;
       font-weight: bold;
    }
  </style>
  <title>$title</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
_END_HTML_HEAD

  if ($next)
  {
     $head .= "<link rel=\"next\" href=\"$next.html\" />";
  }

  if ($prev)
  {
     $head .= "<link rel=\"prev\" href=\"$prev.html\" />";
  }

  "$head</head>";
}

sub html_nav{
  my ($prevNode, $nextNode) = @_;

  my $nav = '<hr /><table width="100%"><tr><td align="left">';

  if ($prevNode)
  {
     my $prev;
     my $title;

     if ($prevNode eq $base)
     {
        $prev = $base;
        $title = &get_label('manual.home');
     } 
     else
     {
        $prev = $prevNode->{Tag};
        $title = $prevNode->{Title};
     }

     $nav .= "<a href=\"$prev.html\">&#x21E6; " .
      $title . "</a>";
  }

  $nav .= '</td><td align="right">';

  if ($nextNode)
  {
     $nav .= "<a href=\"$nextNode->{Tag}.html\">"
          . $nextNode->{Title}
          . " &#x21E8;</a>";
  }

  "$nav</td></tr></table>"
}

sub arg_placeholder{
   "<ARG#" . ($_[0]) . "/>";
}
 
1;

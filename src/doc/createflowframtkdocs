#!/usr/bin/perl -w

use utf8;
use strict;
use XML::Parser;
use File::Copy;

# createflowframtkdocs FlowframTk en GB
# createflowframtkdocs FlowframTk en US
# createflowframtkdocs JDRView en GB
# createflowframtkdocs JDRView en US

if ($#ARGV > 2 || $#ARGV < 0)
{
   die "Syntax: $0 <base> <lang> [<region>]\n";
}

my $base = lc($ARGV[0]);
my $lang = $ARGV[1];

my $locale = $lang;

if ($#ARGV == 2)
{
   $locale .= "-".$ARGV[2];
}

my $downloadurl = 'https://www.dickimaw-books.com/software/flowframtk/';
my $targetdir = '../lib/resources/helpsets';
my $dictdir = '../lib/resources/dictionaries';
my $mainclass = "../java/$base/" . $ARGV[0] . 'Invoker.java';

my $fontenc = 'T1';

my %bibentries = ();
my $bibpending = '';

my %texelements = 
(
   'Title' => '',
   'Date' => '',
   'Author' => '',
);

my $skipnewline = 0;

# mapping between locales and babel options

my %babel =
 (
    'en'    => 'english',
    'en-GB' => 'british',
    'en-US' => 'american',
    'fr'    => 'frenchb'
 );

my $encoding_file = 'utf8';
my $encoding_xml  = 'UTF-8';

my %dict = &load_dict();

my %docinfo = ();
my @nodes   = ();
my @current = ();
my @paragraph = ();
my %tags    = ();
my @currenttag= ();
my @currentattrs= ();
my $includehtml = 1;
my $includetex = 1;
my $boilerplate = 0;

my $xmlfile = "$base-$locale.xml";

if (not (-e $xmlfile) and ($lang ne $locale))
{
   $xmlfile = "$base-$lang.xml";

   unless (-e $xmlfile)
   {
      die "Can't find either '$base-$locale.xml' or '$xmlfile'\n";
   }
}

unless (-e $xmlfile)
{
   die "Can't find '$xmlfile'\n";
}

my $texfile = "$base-$locale.tex";
my $bibfile = "$base-$locale.bib";
my $boilerplatefile = "$base-$locale-boilerplate.tex";
my $langdeffile = "$base-$locale.ldf";

my $helpsetdir = "$targetdir/$base/$locale";

unless (-e $helpsetdir)
{
   mkdir $helpsetdir or die "Can't mkdir '$helpsetdir' $!\n";
}

unless (-d $helpsetdir)
{
   die "'$helpsetdir' is not a directory\n";
}

my $cssfile = "$helpsetdir/$base.css";

# Is there any way of querying the input encoding picked up by
# XML::Parser? Let's just stick to utf8
my $inputenc = 'utf8';
 
my %section_levels =
(
   'chapter'       => '1',
   'section'       => '2',
   'subsection'    => '3',
   'subsubsection' => '4',
   'paragraph'     => '5'
);

my %acros = ();

my %terms = ();

my @float_elements = ();

my @tabular_specs = ();

my %counters = ();

my $boilerfd;
my $texfd;
my $bibfd;

# open the TeX file
open $texfd, ">:encoding($encoding_file)", $texfile
   or die "Can't open TeX file '$texfile' $!\n";

# open the bib file
open $bibfd, ">:encoding($encoding_file)", $bibfile
   or die "Can't open Bib file '$bibfile' $!\n";
print $bibfd "% Encoding: $encoding_xml\n";

print $bibfd '@preamble{"\\providecommand{\\optnoindex}[1]{--#1}"}', "\n";
 
# initialize the parser
my $parser = XML::Parser->new( Handlers => 
                                     {
                                      Start=>\&handle_start,
                                      End=>\&handle_end,
                                      Char=>\&handle_char
                                     });
$parser->parsefile( $xmlfile );
 
close $texfd;
close $bibfd;

&write_language_defs();

# Write helpset files

&write_css();
&write_hs_file();
&write_home_file();
&write_toc_file();
&write_map_file();
&write_index_file();

sub handle_char{
   my( $expat, $string ) = @_;

   &handle_html($string);
   &handle_tex($string);
}

sub firstofone{
   return shift;
}

sub cs_fmt{
   my $csname = shift ;
   return "<code>\\$csname</code>";
}

sub handle_semantic_term{
   my ($tagfield, $type, $htmlfnhandler, $expat, %attrs) = @_;

   unless ($attrs{$tagfield})
   {
      die "Missing '$type' element's '$tagfield' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &$htmlfnhandler($attrs{$tagfield});

   unless ($text=~/^</)
   {
      $text = "<span class=\"$type\">" . $text . "</span>";
   }

   &check_boolean_attribute_value('index', $expat, \%attrs);

   if (defined($attrs{index}) and not $attrs{index})
   {
      my $tex = $attrs{$tagfield};
      $tex=~s/_/\\_/g;
      &handle_tex("\\${type}noindex{$tex}");
      &handle_html($text);
   }
   else
   {
      &handle_tex("\\$type\{", $attrs{$tagfield}, '}');
      &hs_index_term($type.'_'.$attrs{$tagfield}, $text, $attrs{$tagfield}, \%terms);
   }
}

sub hs_index_term{
   my ($tag, $text, $term, $hash) = @_;

   if (defined($hash->{$tag}->{Ref}) or $#nodes < 0)
   {
      &handle_html($text);
   }
   else
   {
      $hash->{$tag}->{Ref}  = $nodes[$#nodes]->{Tag}.".html#$tag";

      &handle_html("<a name=\"$tag\">$text</a>");
   }

   $hash->{$tag}->{Text} = $term;

   unless (defined($bibentries{$tag}))
   {
      my $tex_name = $term;
      my $tex_text = $term;

      $tex_name=~s/_/\\_/g;
      $tex_text=~s/_/\\_/g;

      if ($tag=~/^sty_/)
      {
         $tex_name=~s/^(.*)(\.sty)?$/\\stynoindex{$1} package/;
         $tex_text=~s/^(.*)(\.sty)?$/\\stynoindex{$1}/;
      }
      elsif ($tag=~/^cls_/)
      {
         $tex_name=~s/^(.*)(\.cls)?$/\\clsnoindex{$1} class/;
         $tex_text=~s/^(.*)(\.cls)?$/\\clsnoindex{$1}/;
      }
      elsif ($tag=~/^env_/)
      {
         $tex_name = "\\envnoindex{$tex_name} environment";
         $tex_text = "\\envnoindex{$tex_text}";
      }
      elsif ($tag=~/^envvar_/)
      {
         $tex_name = "\\envvarnoindex{$tex_name} environment variable";
         $tex_text = "\\envvarnoindex{$tex_text}";
      }
      elsif ($tag=~/^(cs|cli|opt|ext)_/)
      {
         $tex_name = "\\$1noindex{$tex_name}";
         $tex_text = $tex_name;
      }

      my $bib = "\@index{$tag, name={$tex_name}, text={$tex_text}";

      if (defined($hash->{$tag}))
      {
         if ($hash->{$tag}->{Parent})
         {
            $bib .= ", parent={" . $hash->{$tag}->{Parent} . "}";
         }

         if ($hash->{$tag}->{Category})
         {
            $bib .= ", category={" . $hash->{$tag}->{Category} . "}";
         }
      }

      $bib .= "}\n";

      if ($#current > -1 and ($current[$#current]=~/^New(Term|Acro)/))
      {
         $bibpending .= $bib;
      }
      else
      {
         print $bibfd $bib;
      }

      $bibentries{$tag} = $tex_name;
   }
}

sub hs_popup{
   my ($href, $text) = @_;

   my $html = <<_END_POPUP;
  <object classid="java:com.sun.java.help.impl.JHSecondaryViewer">
    <param name="viewerStyle" value="javax.help.Popup" />
    <param name="viewerSize" value="400,200" />
    <param name="content" value="$href" />
    <param name="viewerActivator" value="javax.help.LinkLabel" />
    <param name="text" value="&#x261B;" />
    <param name="textColor" value="blue" />
  </object>
_END_POPUP

   $html.$text
}

sub handle_tex{
   my ($string) = join('', @_);

   return unless ($includetex);

   if ($skipnewline)
   {
      $string=~s/^\s*\n(\s*)/ /s;

      unless ($string eq ' ')
      {
         $skipnewline = 0;
      }
   }

   if ($#current > -1)
   {
      my $element = $current[$#current];

      if ($element eq 'NewTerm' or $element eq 'NewAcro')
      {
         print $bibfd $string;
      }
      elsif ($element eq 'Boilerplate')
      {
         print $boilerfd $string;
      }
      else
      {
         $texelements{$element} .= $string;
      }
   }
   else
   {
      print $texfd $string;
   }
}

sub handle_html{
   my ($string) = join('', @_);

   return unless ($includehtml);

   if ($#current > -1)
   {
      my $element = $current[$#current];

      $docinfo{$element} .= $string;
   }
   elsif ($#nodes > -1)
   {
      $nodes[$#nodes]->{Contents} .= $string;
   }
}
 
sub handle_start {
    my( $expat, $element, %attrs ) = @_;

    my $sub = "start_$element";
 
    if (defined(&$sub))
    {
       {
         no strict 'refs';
         &$sub($expat, %attrs);
       }
    }
    else
    {
       die "Don't know what to do with '<$element>'\n";
    }
}

sub handle_end {
    my( $expat, $element ) = @_;
 
    my $sub = "end_$element";

    if (defined(&$sub))
    {
       {
         no strict 'refs';
         &$sub($expat);
       }
    }
    else
    {
       die "Don't know what to do with '</$element>'\n";
    }
}

sub get_ref{
   my ($case, $tag, $content) = @_;

   unless ($tags{$tag})
   {
      die "Unknown tag '$tag'\n";
   }

   my $ref = $tags{$tag}->{Ref};
   my $text;

   if ($content)
   {
      $text = $content;
   }
   else
   {
      $text = $tags{$tag}->{Text};
   }

   if ($case eq 'ucfirst')
   {
      $text = ucfirst($text);
   }

   "<a href=\"$ref\">$text</a>";
}

sub get_label{
   my ($tag, $attrs, $expat) = @_;

   unless ($dict{$tag})
   {
      if (defined($dict{"manual.$tag"}))
      {
         $tag = "manual.$tag";
      }
      elsif ($expat)
      {
         die "No dictionary entry for tag '$tag' on line ",
           $expat->current_line, "\n";
      }
      else
      {
         die "No dictionary entry for tag '$tag'\n";
      }
   }

   my $text = $dict{$tag};

   if ($attrs)
   {
      $text=~s/<ARG#(\d)\/>/$attrs->{"arg$1"}/eg;
   }

   $text
}

sub start_manual{
   my ($expat, %attrs) = @_;

   if ($attrs{fontenc})
   {
      $fontenc = $attrs{'fontenc'};
   }

   print $texfd "% arara: pdflatex\n";
   print $texfd "% arara: bib2gls: { group: on, trimfields: on }\n";
   print $texfd "% arara: pdflatex\n";
   print $texfd "% arara: pdflatex\n";
   print $texfd "\\documentclass[$babel{$locale}]{flowframtk}\n";
}

sub end_manual{
   my ($expat) = @_;
}

sub start_preamble{
   my ($expat, %attrs) = @_;

   print $texfd <<EOF;
\\usepackage[$inputenc]{inputenc}
\\usepackage[$fontenc]{fontenc}
\\usepackage{lmodern}
\\usepackage{cmap}
\\usepackage{accsupp}
\\usepackage{graphicx}
\\usepackage{verbatim}
\\usepackage{alltt}
\\usepackage{array}
\\usepackage{longtable}
\\usepackage{booktabs}
\\usepackage{moreverb}
\\usepackage{keystroke}
\\usepackage{babel}
\\usepackage[colorlinks]{hyperref}
\\usepackage[record=nameref]{glossaries-extra}
\\usepackage{glossaries-prefix}
\\input{$langdeffile}

\\newcommand{\\accsupp}[2]{\\BeginAccSupp{unicode,ActualText={#1}}#2\\EndAccSupp{}}

\\glsxtrnewgls{cli_}{\\cli}
\\glsxtrnewgls{sty_}{\\sty}
\\glsxtrnewgls{cls_}{\\cls}
\\glsxtrnewgls{env_}{\\env}
\\glsxtrnewgls{envvar_}{\\envvar}
\\glsxtrnewgls{ext_}{\\ext}
\\glsxtrnewgls{opt_}{\\opt}

\\providecommand{\\applink}[1]{\\href{$downloadurl/#1}{#1}}
\\csname preresourcehook\\endcsname
\\GlsXtrLoadResources[src={$bibfile}]
EOF
}
 
sub end_preamble{
   my ($expat) = @_;
}

sub start_htmlonly{
   my ($expat, %attrs) = @_;

   unless ($includetex)
   {
      die "Nested <htmlonly> forbidden on line ",
           $expat->current_line, "\n";
   }

   $includetex = 0;
}

sub end_htmlonly{
   my ($expat) = @_;

   $includetex = 1;
}

sub start_latexonly{
   my ($expat, %attrs) = @_;

   unless ($includehtml)
   {
      die "Nested <latexonly> forbidden on line ",
           $expat->current_line, "\n";
   }

   $includehtml = 0;
}

sub end_latexonly{
   my ($expat) = @_;

   $includehtml = 1;
}

sub start_title{
   my ($expat, %attrs) = @_;

   push @current, 'Title';
}

sub end_title{
   my ($expat) = @_;

   pop @current;

   &handle_tex("\\title{", $texelements{Title}, "}");
}

sub start_date{
   my ($expat, %attrs) = @_;

   push @current, 'Date';
}

sub end_date{
   my ($expat) = @_;

   pop @current;

   &handle_tex("\\date{", $texelements{Date}, "}");
}

sub start_author{
   my ($expat, %attrs) = @_;

   push @current, 'Author';

   unless ($docinfo{Author})
   {
      $docinfo{Author} = " ";
   }

   $docinfo{Author} .= "<table class=\"author\"><tr><td align=\"center\">";
}

sub end_author{
   my ($expat) = @_;

   $docinfo{Author} .= "</td></tr></table>";

   pop @current;

   &handle_tex("\\Author{", $texelements{Author}, "}");
}

sub start_document{
   my ($expat, %attrs) = @_;

   print $texfd "\\begin{document}\n\\maketitle\n\n";

   if ($boilerplate)
   {
      print $texfd "\\input{$boilerplatefile}\n";
   }
}

sub end_document{
   my ($expat) = @_;

   print $texfd "\\end{document}\n";
}

sub start_tableofcontents{
   my ($expat, %attrs) = @_;

   &handle_tex("\\tableofcontents\n");
}

sub end_tableofcontents{
   my ($expat, %attrs) = @_;
}

sub start_listoffigures{
   my ($expat, %attrs) = @_;

   &handle_tex("\\listoffigures\n");
}

sub end_listoffigures{
   my ($expat, %attrs) = @_;
}

sub start_listoftables{
   my ($expat, %attrs) = @_;

   &handle_tex("\\listoftables\n");
}

sub end_listoftables{
   my ($expat, %attrs) = @_;
}

sub start_node{
   my ($expat, %attrs) = @_;

   unless ($attrs{type})
   {
      die "Missing 'type' attribute for element 'node' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{tag})
   {
      die "Missing 'tag' attribute for element 'node' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{title})
   {
      die "Missing 'title' attribute for element 'node' on line ",
         $expat->current_line, "\n";
   }

   my $currentlevel = $section_levels{$attrs{type}};

   unless ($currentlevel)
   {
      die "Unknown section level '$attrs{type}' on line ",
         $expat->current_line, "\n";
   }

   my $lastlevel;

   if ($#nodes == -1)
   {
      $lastlevel = 0;
   }
   else
   {
      $lastlevel = $section_levels{$nodes[$#nodes]->{Type}};
   }

   unless ($currentlevel <= $lastlevel+1)
   {
      die "Node '$attrs{tag}' type can't be deeper than '",
        $section_levels{$lastlevel+1},"' on line ",
        $expat->current_line, "\n";
   }

   my $nodetitle = $attrs{title};

   $nodetitle=~s/\|dict (.+?)\|/&eval_dict_attrs($expat, $1, $2)/eg;

   my $htmltitle = $nodetitle;

   $htmltitle=~s/\|cs ([a-zA-Z]+)\|/<tt>\\$1<\/tt>/g;
   $htmltitle=~s/\|sty (.+?)\|/<tt>$1<\/tt>/g;

   my %node = 
   (
      Type      => $attrs{type},
      Title     => $htmltitle,
      Tag       => $attrs{tag},
      Contents  => '',
      Footnotes => '' 
   );

   push @nodes, \%node;

   $tags{$attrs{tag}}->{Ref} = $attrs{tag}.'.html';
   $tags{$attrs{tag}}->{Text} = $htmltitle;

   my $textitle = $nodetitle;
   $textitle=~s/\|(cs|sty) ([a-zA-Z]+)\|/\\$1noindex{$2}/g;

   $textitle=~s/((?:La)TeX)/\\protect\\$1\{\}/g;

   print $texfd "\\", $attrs{type}, "{$textitle}\\label{",
      $attrs{tag}, "}\n";
}

sub end_node{
   my ($expat) = @_;

}

sub start_newacro{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'tag' attribute for element 'newacro' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{short})
   {
      die "Missing 'short' attribute for element 'newacro' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{long})
   {
      die "Missing 'long' attribute for element 'newacro' on line ",
         $expat->current_line, "\n";
   }

   my $tag = $attrs{tag};

   if ($acros{$tag})
   {
      die "Acronym '$tag' already defined\n";
   }

   $acros{$tag}->{Short} = $attrs{short};
   $acros{$tag}->{Long} = $attrs{long};
   $acros{$tag}->{Prefix} = $attrs{prefix};
   $acros{$tag}->{PrefixFirst} = $attrs{prefixfirst};
   $acros{$tag}->{PrefixPlural} = $attrs{prefixplural};
   $acros{$tag}->{PrefixFirstPlural} = $attrs{prefixfirstplural};

   push @current, 'NewAcro';
   push @currenttag, $tag;

   $docinfo{'NewAcro'}='';
   $bibpending = '';

   $bibentries{$tag} = $acros{$tag}->{Long};

   &handle_tex("\@abbreviation{$tag,\n short={" . $acros{$tag}->{Short}
     . "},\n long={" . $acros{$tag}->{Long} . "}");

   if ($acros{$tag}->{Prefix})
   {
      my $prefix = $acros{$tag}->{Prefix};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefix={$prefix}");

      $acros{$tag}->{Prefix}=~s/~/ /g;
   }

   if ($acros{$tag}->{PrefixFirst})
   {
      my $prefix = $acros{$tag}->{PrefixFirst};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefixfirst={$prefix}");

      $acros{$tag}->{PrefixFirst}=~s/~/ /g;
   }

   if ($acros{$tag}->{PrefixPlural})
   {
      my $prefix = $acros{$tag}->{PrefixPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefixplural={$prefix}");

      $acros{$tag}->{PrefixPlural}=~s/~/ /g;
   }

   if ($acros{$tag}->{PrefixFirstPlural})
   {
      my $prefix = $acros{$tag}->{PrefixFirstPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex(",\n prefixfirstplural={$prefix}");

      $acros{$tag}->{PrefixFirstPlural}=~s/~/ /g;
   }

   &handle_tex(",\n description={");
}

sub end_newacro{
   my ($expat) = @_;

   my $tag = pop @currenttag;

   # write html file used by popup window

   open my $fd, ">:encoding($encoding_file)", "$helpsetdir/acr_$tag.html" 
      or die "Can't open '$helpsetdir/acr_$tag.html' $!\n";

   print $fd &html_head($acros{$tag}->{Short});

   print $fd "<body>\n<h1>$acros{$tag}->{Short}</h1>\n",
      ucfirst($acros{$tag}->{Long}), ".\n";

   if ($docinfo{NewAcro})
   {
      $acros{$tag}->{Description} = $docinfo{NewAcro};

      print $fd "<p>", $acros{$tag}->{Description}, "</p>\n";
   }

   print $fd "</body>\n</html>\n";

   close $fd;

   &handle_tex("}\n}\n");

   pop @current;

   print $bibfd $bibpending;
}
 
sub start_newterm{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'tag' attribute for element 'newterm' on line ",
         $expat->current_line, "\n";
   }

   unless ($attrs{text})
   {
      $attrs{text} = $attrs{tag};
   }

   my $currenttag = $attrs{tag};
   push @currenttag, $attrs{tag};
   my $tag = 'gls_'.$attrs{tag};

   if ($terms{$tag})
   {
      die "Term '", $attrs{tag}, "' already defined\n";
   }

   $terms{$tag}->{Text} = $attrs{text};

   push @current, 'NewTerm';
   $docinfo{'NewTerm'}='';
   $bibpending = '';

   &handle_tex("\@index{", $attrs{tag}, ",\n name={" . $terms{$tag}->{Text} . "},");

   $bibentries{$attrs{tag}} = $terms{$tag}->{Text};

   if (defined($attrs{plural}))
   {
      $terms{$tag}->{Plural} = $attrs{plural};
      &handle_tex("\n plural={", $attrs{plural}, "},");
   }

   if (defined($attrs{seealso}))
   {
      $terms{$tag}->{SeeAlso} = $attrs{seealso};
      &handle_tex("\n seealso={", $attrs{seealso}, "},");
   }

   if (defined($attrs{see}))
   {
      $terms{$tag}->{See} = $attrs{see};
      &handle_tex("\n see={", $attrs{see}, "},");
   }

   if (defined($attrs{alias}))
   {
      $terms{$tag}->{Alias} = $attrs{alias};
      &handle_tex("\n alias={", $attrs{alias}, "},");
   }

   if (defined($attrs{prefix}))
   {
      $terms{$tag}->{Prefix} = $attrs{prefix};
      my $prefix = $terms{$tag}->{Prefix};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefix={$prefix},");

      $terms{$tag}->{Prefix}=~s/~/ /g;
   }

   if (defined($attrs{prefixfirst}))
   {
      $terms{$tag}->{PrefixFirst} = $attrs{prefixfirst};
      my $prefix = $terms{$tag}->{PrefixFirst};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefixfirst={$prefix},");

      $terms{$tag}->{PrefixFirst}=~s/~/ /g;
   }

   if (defined($attrs{prefixplural}))
   {
      $terms{$tag}->{PrefixPlural} = $attrs{prefixplural};
      my $prefix = $terms{$tag}->{PrefixPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefixplural={$prefix},");

      $terms{$tag}->{PrefixPlural}=~s/~/ /g;
   }

   if (defined($attrs{prefixfirstplural}))
   {
      $terms{$tag}->{PrefixFirstPlural} = $attrs{prefixfirstplural};
      my $prefix = $terms{$tag}->{PrefixFirstPlural};

      $prefix=~s/ +$/\\space/;

      &handle_tex("\n prefixfirstplural={$prefix},");

      $terms{$tag}->{PrefixFirstPlural}=~s/~/ /g;
   }

   &handle_tex("\n description={");
}

sub end_newterm{
   my ($expat) = @_;

   if ($docinfo{NewTerm})
   {
      my $tag = 'gls_'.(pop @currenttag);
      $terms{$tag}->{Description} = $docinfo{NewTerm};

      # write html file used by popup window if a description has been
      # supplied

      open my $fd, ">:encoding($encoding_file)", "$helpsetdir/$tag.html" 
         or die "Can't open '$helpsetdir/$tag.html' $!\n";

      print $fd &html_head($terms{$tag}->{Text});

      print $fd "<body>\n<h1>", $terms{$tag}->{Text}, "</h1>\n",
         ucfirst($terms{$tag}->{Description}), "\n";

      print $fd "</body>\n</html>\n";

      close $fd;

   }

   &handle_tex("}}\n");

   pop @current;

   print $bibfd $bibpending;
}

sub check_boolean_attribute_value{
   my ($attr_name, $expat, $attrs) = @_;

   if ($attrs->{$attr_name})
   {
      my $value = lc($attrs->{$attr_name});

      if ($value eq 'true' or $value eq 1)
      {
         $value = 1;
      }
      elsif ($value eq 'false' or $value eq 0)
      {
         $value = 0;
      }
      else
      {
         die "Invalid value '$value' of attribute 'short' on line ",
           $expat->current_line, "\n";
      }

      $attrs->{$attr_name} = $value;
   }
}
 
sub start_frontmatter{
   my ($expat, %attrs) = @_;

   &handle_tex('\\frontmatter ');
}

sub end_frontmatter{
   my ($expat) = @_;
}

sub start_mainmatter{
   my ($expat, %attrs) = @_;

   &handle_tex('\\mainmatter ');
}

sub end_mainmatter{
   my ($expat) = @_;
}

sub start_backmatter{
   my ($expat, %attrs) = @_;

   &handle_tex('\\backmatter ');
}

sub end_backmatter{
   my ($expat) = @_;
}

sub start_boilerplate{
   my ($expat, %attrs) = @_;

   open $boilerfd, ">:encoding($encoding_file)", $boilerplatefile
     or die "Can't open boilerplate file '$boilerplatefile' $!\n";

   push @current, 'Boilerplate';
   &handle_tex('\\begin{boilerplate}');
}

sub end_boilerplate{
   my ($expat) = @_;
   &handle_tex('\\end{boilerplate}');
   pop @current;

   $boilerplate = 1;
   close $boilerfd;
}

sub start_p{
   my ($expat, %attrs) = @_;

   my $endtag="\n\n";

   &check_boolean_attribute_value('short', $expat, \%attrs);
   &check_boolean_attribute_value('indent', $expat, \%attrs);

   if ($attrs{'short'})
   {
      $endtag='\\glspar ';
   }

   if ($attrs{tag})
   {
      my $text = ($attrs{tagtext} ? $attrs{tagtext} : $attrs{tag});

      if (!defined($terms{tag}) and $#nodes > -1)
      {
         $terms{$attrs{tag}}->{Ref} = $nodes[$#nodes]->{Tag} . ".html#" . $attrs{tag};
         $terms{$attrs{tag}}->{Text} = $text;
      }

      &handle_html("<a name=\"", $attrs{tag}, "\"></a>");
      &handle_tex("\\plabel{", $attrs{tag}, "}{$text}");
   }

   &handle_html("<p");

   if ($attrs{align})
   {
      &handle_html(' align="'.$attrs{'align'}.'">');

      if ($attrs{align} eq 'left')
      {
         &handle_tex("\\begin{flushleft}");
         $endtag="\\end{flushleft}";
      }
      elsif ($attrs{align} eq 'right')
      {
         &handle_tex("\\begin{flushright}");
         $endtag="\\end{flushright}";
      }
      elsif ($attrs{align} eq 'center')
      {
         &handle_tex("\\begin{center}");
         $endtag="\\end{center}";
      }
      else
      {
         die "Unknown alignment option", $attrs{align},
          " for 'p' element on line ", $expat->current_line, "\n";
      }
   }
   elsif ($attrs{icon})
   {
      &handle_html('>');

      my %img_attrs = ('align'=>'left');

      if ($attrs{icon} eq 'warning')
      {
         $img_attrs{src} = "warning.png";
         $img_attrs{alt} = &get_label("manual.warning");
      }
      elsif ($attrs{icon}=~/^(tex|pgf|flf)$/)
      {
         $img_attrs{src} = "$1related.png";
         $img_attrs{alt} = &get_label("manual.$1relatedtext");
      }
      else
      {
         my $base;

         # All images are png files. Check if suffix is present.

         if ($attrs{icon}=~/(.*)\.png$/)
         {
            $base = $1;
            $img_attrs{src} = $attrs{icon};
         }
         else
         {
            $base = $attrs{icon};
            $img_attrs{src} = $attrs{icon}.'.png';
         }

         if (defined($dict{"tooltip.$base"}))
         {
            $img_attrs{alt} = $dict{"tooltip.$base"} . '.';
         }
         else
         {
            $img_attrs{alt} = ucfirst($base) . '.';
         }
      }

      &do_image('iconstartpar', $expat, %img_attrs);
   }
   else
   {
      &handle_html(">");
      &handle_tex($endtag);

      &handle_tex("\\noindent ") if $attrs{noindent};
   }

   push @paragraph, $endtag;
   $skipnewline = 1;
}

sub end_p{
   my ($expat) = @_;

   &handle_html("</p>");

   &handle_tex(pop @paragraph);
}

sub start_dl{
   my ($expat, %attrs) = @_;

   &handle_html("<dl>");

   &handle_tex("\\begin{description}");
}

sub end_dl{
   my ($expat) = @_;

   &handle_html("</dl>");

   &handle_tex("\\end{description}");
}

sub start_ul{
   my ($expat, %attrs) = @_;

   &handle_html("<ul>");

   &handle_tex("\\begin{itemize}");
}

sub end_ul{
   my ($expat) = @_;

   &handle_html("</ul>");

   &handle_tex("\\end{itemize}");
}

sub start_tt{
   my ($expat, %attrs) = @_;

   &handle_html("<tt>");

   &handle_tex("\\texttt{");
}

sub end_tt{
   my ($expat) = @_;

   &handle_html('</tt>');

   &handle_tex("}");
}

sub start_b{
   my ($expat, %attrs) = @_;

   &handle_html("<b>");

   &handle_tex("\\textbf{");
}

sub end_b{
   my ($expat) = @_;

   &handle_html('</b>');

   &handle_tex("}");
}

sub start_em{
   my ($expat, %attrs) = @_;

   &handle_html("<em>");

   &handle_tex("\\emph{");
}

sub end_em{
   my ($expat) = @_;

   &handle_html('</em>');

   &handle_tex("}");
}

sub start_kbd{
   my ($expat, %attrs) = @_;

   unless ($attrs{key})
   {
      die "element 'kbd' missing 'key' attribute\n";
   }

   my $pre = $attrs{pre};
   my $post = $attrs{post};

   my $key = ucfirst($attrs{key});

   &check_boolean_attribute_value('shift', $expat, \%attrs);
   &check_boolean_attribute_value('ctrl', $expat, \%attrs);
   &check_boolean_attribute_value('alt', $expat, \%attrs);

   if ($attrs{'alt'})
   {
      &keypress('Alt', $pre);
      &handle_tex('+');
      &handle_html('+');
      undef $pre if ($pre);
   }

   if ($attrs{'ctrl'})
   {
      &keypress('Ctrl', $pre);
      &handle_tex('+');
      &handle_html('+');
      undef $pre if ($pre);
   }

   if ($attrs{'shift'})
   {
      &keypress('Shift', $pre);
      &handle_tex('+');
      &handle_html('+');
      undef $pre if ($pre);
   }

   &keypress($key, $pre, $post);
}

sub keypress{
   my ($key, $pre, $post) = @_;

   my $init = '';

   if (defined($pre) and $pre ne 'none')
   {
      $init = "\\def\\prekeystroke{$pre}";
   }
   elsif ($skipnewline or $pre)
   {
      $init = "\\def\\prekeystroke{}";
   }

   if (defined($post) and $post eq 'none')
   {
      $init .= "\\def\\postkeystroke{}";
   }
   elsif ($post)
   {
      $init .= "\\def\\postkeystroke{$post}";
   }

   if ($init)
   {
      &handle_tex("{$init");
   }

   if ($key eq 'Space')
   {
      my $text = &get_label("manual.kbd.Space");
      &handle_tex("\\accsupp{$text}{\\Spacebar}");
      &handle_html("<kbd>$text</kbd>");
   }
   elsif ($key eq 'Return')
   {
      my $text = &get_label("manual.kbd.Return");
      &handle_tex("\\accsupp{$text}{\\Return}");
      &handle_html("<kbd>$text &#x23CE;</kbd>");
   }
   elsif ($key eq 'Backspace')
   {
      my $text = &get_label("manual.kbd.Backspace");
      &handle_tex("\\accsupp{$text}{\\BSpace}");
      &handle_html("<kbd>$text &#x21A4;</kbd>");
   }
   elsif ($key eq 'Tab')
   {
      my $text = &get_label("manual.kbd.Tab");
      &handle_tex("\\accsupp{$text}{\\Tab}");
      &handle_html("<kbd>$text &#x21B9;</kbd>");
   }
   elsif ($key eq 'Pgup')
   {
      my $text = &get_label("manual.kbd.Pageup");
      &handle_tex("\\accsupp{$text}{\\keystroke{$text \$\\uparrow\$}}");
      &handle_html("<kbd>$text &#x2191;</kbd>");
   }
   elsif ($key eq 'Pgdn')
   {
      my $text = &get_label("manual.kbd.Pagedown");
      &handle_tex("\\accsupp{$text}{\\keystroke{$text \$\\downarrow\$}}");
      &handle_html("<kbd>$text &#x2193;</kbd>");
   }
   elsif ($key eq 'Shift')
   {
      my $text = &get_label("manual.kbd.Shift");
      &handle_tex("\\accsupp{$text}{\\keystroke{$text \$\\Uparrow\$}}");
      &handle_html("<kbd>$text &#x21D1;</kbd>");
   }
   elsif ($key eq 'Up')
   {
      my $text = &get_label("manual.kbd.Up");
      &handle_tex("\\accsupp{$text}{\\UArrow}");
      &handle_html("<kbd title=\"$text\">&#x2191;</kbd>");
   }
   elsif ($key eq 'Down')
   {
      my $text = &get_label("manual.kbd.Down");
      &handle_tex("\\accsupp{$text}{\\DArrow}");
      &handle_html("<kbd title=\"$text\">&#x2193;</kbd>");
   }
   elsif ($key eq 'Left')
   {
      my $text = &get_label("manual.kbd.Left");
      &handle_tex("\\accsupp{$text}{\\LArrow}");
      &handle_html("<kbd title=\"$text\">&#x2190;</kbd>");
   }
   elsif ($key eq 'Right')
   {
      my $text = &get_label("manual.kbd.Right");
      &handle_tex("\\accsupp{$text}{\\RArrow}");
      &handle_html("<kbd title=\"$text\">&#x2192;</kbd>");
   }
   elsif (defined($dict{"manual.kbd.".$key}))
   {
      &handle_tex("\\keystroke{", $dict{"manual.kbd.".$key}, "}");
      &handle_html("<kbd>$key</kbd>");
   }
   else
   {
      &handle_tex("\\keystroke{$key}");
      &handle_html("<kbd>$key</kbd>");
   }

   if ($init)
   {
      &handle_tex("}");
   }

}

sub end_kbd{
   my ($expat) = @_;

}

sub start_file{
   my ($expat, %attrs) = @_;

   &handle_html("<tt>");

   &handle_tex("\\file{");
}

sub end_file{
   my ($expat) = @_;

   &handle_html('</tt>');

   &handle_tex("}");
}

sub start_li{
   my ($expat, %attrs) = @_;

   &handle_html("<li>");

   &handle_tex("\\item ");
}

sub end_li{
   my ($expat) = @_;

   &handle_html("</li>");
}


sub start_dt{
   my ($expat, %attrs) = @_;

   &handle_html("<dt>");

   &handle_tex("\\item[{");
}

sub end_dt{
   my ($expat) = @_;

   &handle_html("</dt>");

   &handle_tex("}]");
}

sub start_dd{
   my ($expat, %attrs) = @_;

   &handle_html("<dd>");

}

sub end_dd{
   my ($expat) = @_;

   &handle_html("</dd>");

}

sub start_meta{
   my ($expat, %attrs) = @_;

   &handle_html("&#x27E8;<em>");

   &handle_tex("\\meta{");
}

sub end_meta{
   my ($expat) = @_;

   &handle_html('</em>&#x27E9;');

   &handle_tex("}");
}

sub start_marg{
   my ($expat, %attrs) = @_;

   &handle_html('{');

   &handle_tex("\\marg{");
}

sub end_marg{
   my ($expat) = @_;

   &handle_html('}');

   &handle_tex("}");
}

sub start_dq{
   my ($expat, %attrs) = @_;

   &handle_html('"');

   &handle_tex("\\dq{");
}

sub end_dq{
   my ($expat) = @_;

   &handle_html('"');

   &handle_tex("}");
}

sub start_url{
   my ($expat, %attrs) = @_;

   unless ($attrs{www})
   {
      die "element 'url' missing 'www' attribute\n";
   }

   my $string;

   my $uri = $attrs{www};

   $uri = "http://$uri" unless ($uri=~/^[a-z]+:\/\//);

   if ($attrs{text})
   {
      &handle_tex("\\href{", $attrs{www}, "}{", $attrs{text}, "}");
      $string = "<a href=\"$uri\">$attrs{text}</a>";
   }
   else
   {
      &handle_tex("\\url{", $attrs{www}, "}");
      $string = "<a href=\"$uri\"><tt>$attrs{www}</tt></a>";
   }

   &handle_html($string);
}

sub end_url{
   my ($expat) = @_;
}

sub start_sty{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'sty', \&firstofone, $expat, %attrs);
}

sub end_sty{
   my ($expat) = @_;
}

sub start_cli{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'cli', \&firstofone, $expat, %attrs);
}

sub end_cli{
   my ($expat) = @_;
}

sub start_ext{
   my ($expat, %attrs) = @_;

   unless ($attrs{name})
   {
      die "Missing 'ext' element's 'name' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = $attrs{name};

   unless ($terms{fileextensions})
   {
      &hs_index_term('fileextensions', '', &get_label('manual.file.extensions'), \%terms);

      my %hash = ();

      $terms{fileextensions}->{Children} = \%hash;
   }

   my $tag = 'ext_'.$attrs{name};

   $terms{fileextensions}->{Children}->{$tag}->{Parent} = 'fileextensions';

   &hs_index_term($tag, "<span class=\"ext\">.$text</span>", $text, 
      $terms{fileextensions}->{Children});

   &handle_tex("\\ext{", $attrs{name}, "}");
}

sub end_ext{
   my ($expat) = @_;
}

sub start_footnote{
   my ($expat, %attrs) = @_;

   if ($counters{footnote})
   {
      $counters{footnote} = 1;
   }
   else
   {
      $counters{footnote}++;
   }

   $nodes[$#nodes]->{Contents} .=
     "<sup><a href=\"#fn-$counters{footnote}\">$counters{footnote}</a></sup>";

   push @current, 'Footnote';

   $docinfo{Footnote} = '';
   $texelements{Footnote} = '';
}

sub end_footnote{
   my ($expat) = @_;

   pop @current;

   $nodes[$#nodes]->{Footnotes} .=
     "<p><sup><a name=\"fn-$counters{footnote}\">$counters{footnote}</a></sup>"
     . $docinfo{Footnote}
     . '</p>';

   $docinfo{Footnote} = '';

   &handle_tex("\\footnote{", $texelements{Footnote}, "}");
}

sub start_example{
   my ($expat, %attrs) = @_;

   if ($counters{example})
   {
      $counters{example}++;
   }
   else
   {
      $counters{example} = 1;
   }

   &handle_html('<blockquote><p><b>'
    . &get_label('manual.example')
    . '&nbsp;' . $counters{example}
    . ($attrs{title}? "($attrs{title})." : '.')
    . '</b></p>');

   &handle_tex("\\begin{example}");

   if ($attrs{title})
   {
      &handle_tex('[', $attrs{title}, ']');
   }
}

sub end_example{
   my ($expat) = @_;

   &handle_html('</blockquote>');

   &handle_tex("\\end{example}");
}

sub start_seealso{
   my ($expat, %attrs) = @_;

   unless ($attrs{tags})
   {
      die "Element 'seealso' missing 'tags' attribute on line ",
        $expat->current_line, "\n";
   }

   my @tags = split /,/, $attrs{tags};

   my $seealso = &get_label('manual.seealso');

   &handle_html("<p>$seealso<ul>");

   &handle_tex("\n\n\\minisec{$seealso}\n");

   &handle_tex("\\begin{itemize}\n");

   foreach my $tag (@tags)
   {
      &handle_html("<li><ref case=\"none\" tag=\"$tag\"></ref>");
      &handle_tex("\\item \\nameref{$tag}\n");
   }

   &handle_tex("\\end{itemize}\n");

   &handle_html('</ul>');
}

sub end_seealso{
   my ($expat) = @_;
}

sub start_pre{
   my ($expat, %attrs) = @_;

   &handle_html('<pre>');

   &handle_tex("\\begin{verbatim}");
}

sub end_pre{
   my ($expat) = @_;

   &handle_html('</pre>');

   &handle_tex("\\end{verbatim}");
}

sub start_alltt{
   my ($expat, %attrs) = @_;

   &handle_html('<pre>');

   &handle_tex("\\begin{alltt}");
}

sub end_alltt{
   my ($expat) = @_;

   &handle_html('</pre>');

   &handle_tex("\\end{alltt}");
}

sub start_prompt{
   my ($expat, %attrs) = @_;

   &handle_html('<pre>');

   &handle_tex("\\begin{prompt}");
}

sub end_prompt{
   my ($expat) = @_;

   &handle_html('</pre>');

   &handle_tex("\\end{prompt}");
}

sub start_verb{
   my ($expat, %attrs) = @_;

   &handle_html('<pre style="display: inline;">');

   &handle_tex("\\verb");

   &check_boolean_attribute_value('visiblespace', $expat, \%attrs);

   if ($attrs{visiblespace})
   {
      &handle_tex('*');
   }

   if (defined($attrs{char}))
   {
      &handle_tex($attrs{char});
   }
   else
   {
      &handle_tex('|');
   }

   push @currentattrs, \%attrs;
}

sub end_verb{
   my ($expat) = @_;

   my $attrs = pop @currentattrs;

   &handle_html('</pre>');

   if (defined($attrs->{char}))
   {
      &handle_tex($attrs->{char});
   }
   else
   {
      &handle_tex('|');
   }

}

sub start_verbinput{
   my ($expat, %attrs) = @_;

   unless ($attrs{src})
   {
      die "Missing 'verbinput' element's 'src' attribute on line ",
        $expat->current_line, "\n";
   }

   &handle_html('<pre>');

   open my $fd, ">:encoding($encoding_file)", $attrs{src}
     or die "Can't open verbatim file '$attrs{src}' $!\n";

   while (<$fd>)
   {
      s/\&/\&amp;/g;
      s/</\&lt;/g;
      s/>/\&gt;/g;

      &handle_html($_);
   }

   close $fd;

   &handle_html('</pre>');

   &handle_tex("\\verbatiminput{$attrs{src}}");
}

sub end_verbinput{
   my ($expat) = @_;
}
 
sub start_verbtabinput{
   my ($expat, %attrs) = @_;

   unless ($attrs{src})
   {
      die "Missing 'verbtabinput' element's 'src' attribute on line ",
        $expat->current_line, "\n";
   }

   &handle_html('<pre>');

   open my $fd, ">:encoding($encoding_file)", $attrs{src}
     or die "Can't open '$attrs{src}' $!\n";

   while (<$fd>)
   {
      s/\&/\&amp;/g;
      s/</\&lt;/g;
      s/>/\&gt;/g;

      &handle_html($_);
   }

   close $fd;

   &handle_html('</pre>');

   &handle_tex("\\verbatimtabinput{$attrs{src}}");
}

sub end_verbtabinput{
   my ($expat) = @_;
}
 
sub start_nbsp{
   my ($expat, %attrs) = @_;

   &handle_html('&nbsp;');

   &handle_tex("~");
}

sub end_nbsp{
   my ($expat) = @_;
}

sub start_qquad{
   my ($expat, %attrs) = @_;

   &handle_html('<span class="qquad"></span>');

   &handle_tex("\\qquad ");
}

sub end_qquad{
   my ($expat) = @_;
}

sub start_fndagmark{
   my ($expat, %attrs) = @_;

   &handle_html('<sup>&#x2020;</sup>');

   &handle_tex("\\fndagmark{}");
}

sub end_fndagmark{
   my ($expat) = @_;
}

sub start_emdash{
   my ($expat, %attrs) = @_;

   &handle_html('&#x2014;');

   &handle_tex("---");
}

sub end_emdash{
   my ($expat) = @_;
}

sub start_ldots{
   my ($expat, %attrs) = @_;

   &handle_html('&#x2026;');

   &check_boolean_attribute_value('space', $expat, \%attrs);

   if ($attrs{space})
   {
      &handle_tex("\\ldots\\ ");
   }
   else
   {
      &handle_tex("\\ldots ");
   }

}

sub end_ldots{
   my ($expat) = @_;
}

sub start_hash{
   my ($expat, %attrs) = @_;

   &handle_html('<code>#</code>');

   &handle_tex("\\texttt{\\#}");
}

sub end_hash{
   my ($expat) = @_;
}

sub start_tilde{
   my ($expat, %attrs) = @_;

   &handle_html('~');

   &handle_tex("\\textasciitilde ");
}

sub end_tilde{
   my ($expat) = @_;
}

sub start_lt{
   my ($expat, %attrs) = @_;

   &handle_html('&lt;');

   &handle_tex("\\textless ");
}

sub end_lt{
   my ($expat) = @_;
}

sub start_gt{
   my ($expat, %attrs) = @_;

   &handle_html('&gt;');

   &handle_tex("\\textgreater ");
}

sub end_gt{
   my ($expat) = @_;
}

sub start_element{
   my ($expat, %attrs) = @_;

   &handle_html('<code>&lt;');

   &handle_tex("\\element{");
}

sub end_element{
   my ($expat) = @_;

   &handle_html('&gt;</code>');

   &handle_tex("}");
}

sub do_image{
   my ($texcs, $expat, %attrs) = @_;

   unless ($attrs{src})
   {
      die "Missing 'image' element's 'src' attribute on line ",
        $expat->current_line, "\n";
   }

   &handle_html("<img ");

   my $imgfile = $attrs{src};

   # First try images-<locale> sub-directory
   # Then sharedimages directory
   # Then ../java/jdrresources/icons
   # Then ../java/jdrresources/icons/buttons
   # The last two are in jdrresources.jar but the jar protocol
   # doesn't allow for relative paths to the jar file.
   # (Ideally need
   # src="jar:../../../../jdrresources.jar!/com/dickimawbooks/jdrresources/icons/etc"
   # but this doesn't work.)
   # As a workaround, copy the image to the helpsets/sharedimages
   # directory.

   if (-e "images-$locale/$imgfile")
   {
      $imgfile = "images-$locale/$imgfile";
      &handle_html("src=\"$imgfile\" ");
   }
   elsif (-e "sharedimages/$imgfile")
   {
      &handle_html("src=\"../../sharedimages/$imgfile\" ");
      $imgfile = "sharedimages/$imgfile";
   }
   elsif (-e "../java/jdrresources/icons/$imgfile")
   {
      &handle_html("src=\"../../sharedimages/$imgfile\" ");

      my $targetimg = "$targetdir/sharedimages/$imgfile";
      $imgfile = "../java/jdrresources/icons/$imgfile";

      unless (-e $targetimg)
      {
         copy($imgfile, $targetimg) or die "Failed to copy '$imgfile' to '$targetimg' $!\n";
      }
   }
   elsif (-e "../java/jdrresources/icons/buttons/$imgfile")
   {
      &handle_html("src=\"../../sharedimages/$imgfile\" ");

      my $targetimg = "$targetdir/sharedimages/$imgfile";
      $imgfile = "../java/jdrresources/icons/buttons/$imgfile";

      unless (-e $targetimg)
      {
         copy($imgfile, $targetimg) or die "Failed to copy '$imgfile' to '$targetimg' $!\n";
      }
   }
   else
   {
      die "Can't find image file '$imgfile' referenced on line ",
         $expat->current_line, "\n";
   }

   my @opts=();

   foreach my $key (keys %attrs)
   {
      if ($key eq 'scale')
      {
         push @opts, "scale=$attrs{scale}";
      }
      elsif ($key eq 'width')
      {
         push @opts, "width=$attrs{width}";
         &handle_html("$key=\"$attrs{$key}\" ");
      }
      elsif ($key eq 'height')
      {
         push @opts, "height=$attrs{height}";
         &handle_html("$key=\"$attrs{$key}\" ");
      }
      elsif (not $key eq 'src')
      {
         &handle_html("$key=\"$attrs{$key}\" ");
      }
   }

   if (not $attrs{width} or not $attrs{height})
   {
      # get image dimensions

      $_ = `file $imgfile`;

      if (/(\d+) x (\d+)/)
      {
         &handle_html("width=\"$1\" ") unless $attrs{width};
         &handle_html("height=\"$2\" ") unless $attrs{height};
      }
      else
      {
         warn "Can't determine dimensions of image '$imgfile'\n";
      }
   }

   &handle_html('/>');

   my $optionalarg = ($#opts > -1 ? "[" . join(',', @opts) . "]" : '');

   if ($attrs{alt})
   {
      &handle_tex("\\accsupp{", $attrs{alt}, "}{\\", $texcs, 
        "$optionalarg\{", $attrs{src}, "}}");
   }
   else
   {
      &handle_tex("\\", $texcs, "$optionalarg\{", $attrs{src}, "}");
   }
}

sub start_image{
   my ($expat, %attrs) = @_;

   &do_image('includegraphics', $expat, %attrs);
}

sub end_image{
   my ($expat) = @_;
}

sub start_LaTeX{
   my ($expat, %attrs) = @_;

   &handle_html('LaTeX');

   &handle_tex("\\LaTeX{}");
}

sub end_LaTeX{
   my ($expat) = @_;
}

sub start_TeX{
   my ($expat, %attrs) = @_;

   &handle_html('TeX');

   &handle_tex("\\TeX{}");
}

sub end_TeX{
   my ($expat) = @_;
}

sub start_relax{
   my ($expat, %attrs) = @_;

   &handle_tex("\\relax ");
}

sub end_relax{
   my ($expat) = @_;
}

sub start_app{
   my ($expat, %attrs) = @_;

   my $tag="appname";

   my $text = &get_label($tag, \%attrs, $expat);

   if (defined($attrs{class}) and $attrs{class} eq 'cli')
   {
      $attrs{name} = lc($text);
      &handle_semantic_term('name', 'cli', \&firstofone, $expat, %attrs);
   }
   else
   {
      &handle_html("<span class=\"app\">$text</span>");
      &handle_tex("\\appfmt{$text}");
   }
}

sub end_app{
   my ($expat) = @_;
}

sub start_appversion{
   my ($expat, %attrs) = @_;

   my $tag="appversion";

   my $text = &get_label($tag, \%attrs, $expat);

   &handle_html($text);

   &handle_tex($text);
}

sub end_appversion{
   my ($expat) = @_;
}

sub start_applink{
   my ($expat, %attrs) = @_;

   $docinfo{AppLink} = '';
   $texelements{AppLink} = '';

   push @current, 'AppLink';
}

sub end_applink{
   my ($expat) = @_;

   pop @current;

   my $file = $docinfo{AppLink};

   &handle_html("<a href=\"$downloadurl/$file\" class=\"file\">$file</a>");

   &handle_tex("\\applink{", $texelements{AppLink}, "}");
}

sub eval_dict_attrs{
   my ($expat, $str) = @_;
   my %attrs = ();

   while ($str=~/([a-z]+)\s*=\s*([a-z]+)/g)
   {
      $attrs{$1} = $2;
   }

   unless ($attrs{tag})
   {
      die "Missing 'dict' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &get_label($attrs{tag}, \%attrs, $expat);

   if (defined($attrs{case}))
   {
      if ($attrs{case} eq 'ucfirst')
      {
         $text = ucfirst($text);
      }
      elsif ($attrs{case} eq 'uc')
      {
         $text = uc($text);
      }
      elsif ($attrs{case} eq 'lc')
      {
         $text = lc($text);
      }
      elsif ($attrs{case} ne 'none')
      {
         die "Unknown 'case' value '", $attrs{case}, "' for 'dict' element on line ",
          $expat->current_line, "\n";
      }
   }

   return $text;
}

sub start_mnemonic{
   my ($expat, %attrs) = @_;

   &check_boolean_attribute_value('menu', $expat, \%attrs);

   unless (defined($attrs{menu}))
   {
      $attrs{menu} = 0;
   }

   unless ($attrs{tag})
   {
      die "Missing 'mnemonic' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   if ($attrs{menu})
   {
      my @split = split /\./, $attrs{tag};

      &keypress('Alt', $attrs{pre});

      my $sep = '+';
      my $parent = '';
      my $skipping = 0;

      for (my $idx = 0; $idx <= $#split; $idx++)
      {
         my $subtag = $split[$idx];
         unless (defined($dict{"$parent$subtag.mnemonic"}))
         {
            $parent .= $subtag.'.';
            $skipping = 1;
            next;
         }

         &handle_html($sep);
         &handle_tex($sep);

         &keypress(&get_label("$parent$subtag.mnemonic", \%attrs, $expat), '',
           $idx == $#split ? $attrs{post} : '');

         $sep = ' ';

         $parent .= $subtag.'.';
         $skipping = 0;
      }

      if ($skipping)
      {
         die "Can't find mnemonic for '", $attrs{tag}, "' on line ",
           $expat->current_line, "\n";
      }
   }
   else
   {
      &keypress(&get_label($attrs{tag}.'.mnemonic', \%attrs, $expat), 
         $attrs{pre}, $attrs{post});
   }
}

sub end_mnemonic{
   my ($expat) = @_;
}

sub start_dict{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'dict' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &get_label($attrs{tag}, \%attrs, $expat);

   if (defined($attrs{case}))
   {
      if ($attrs{case} eq 'ucfirst')
      {
         $text = ucfirst($text);
      }
      elsif ($attrs{case} eq 'uc')
      {
         $text = uc($text);
      }
      elsif ($attrs{case} eq 'lc')
      {
         $text = lc($text);
      }
      elsif ($attrs{case} ne 'none')
      {
         die "Unknown 'case' value '", $attrs{case}, "' for 'dict' element on line ",
          $expat->current_line, "\n";
      }
   }

   &handle_html($text);
   &handle_tex($text);
}

sub end_dict{
   my ($expat) = @_;
}
 
sub start_button{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'button' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = &get_label($attrs{tag}, \%attrs, $expat);

   $text=~s/:\s*$//;

   &handle_html("<b>$text</b>");

   &handle_tex("\\button{$text}");
}

sub end_button{
   my ($expat) = @_;
}
 
sub start_menu{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'menu' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $hash = \%terms;

   my $currentlabel;
   my $html  = '';
   my $parent = '';

   foreach my $item (split /\./, $attrs{tag})
   {
      if ($currentlabel)
      {
         $currentlabel .= ".$item";
         &handle_tex("\\mto ");
         $html .= '&#x279C;';
      }
      else
      {
         $currentlabel = $item;
      }

      my $text = &get_label($currentlabel, \%attrs, $expat);

      $html .= $text;

      &handle_tex("\\menu{$text}");

      my $termtag = 'menu_'.$currentlabel;

      if ($parent)
      {
         $hash->{$termtag}->{Parent} = $parent;
      }

      &hs_index_term($termtag, "", $text, $hash);

      unless ($hash->{$termtag}->{Children})
      {
         my %h = ();
         $hash->{$termtag}->{Children} = \%h;
      }

      $hash = $hash->{$termtag}->{Children};

      $parent = $termtag;
   }

   &handle_html("<span class=\"menu\">$html</span>");

   &handle_tex("\\glsadd{$attrs{tag}");
}

sub end_menu{
   my ($expat) = @_;
}
 
sub start_acr{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'acr' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   unless ($acros{$attrs{tag}})
   {
      die "Unknown acronym tag '$attrs{tag}' on line ",
         $expat->current_line, "\n";
   }

   &check_boolean_attribute_value('prefix', $expat, \%attrs);
   &check_boolean_attribute_value('plural', $expat, \%attrs);

   if (!defined($attrs{'case'}))
   {
      $attrs{'case'} = 'none';
   }

   unless ($attrs{'case'}=~/^none|uc(first)?$/)
   {
      die "Unknown case value '", $attrs{'case'}, "' for acr '",
       $attrs{'tag'}, "' on line", $expat->current_line, "\n";
   }

   my $html = '';

   if ($acros{$attrs{tag}}->{Used} or $#nodes == -1)
   {
      if ($attrs{prefix} and $acros{$attrs{tag}}->{Prefix})
      {
         $html = $acros{$attrs{tag}}->{Prefix};
      }

      if ($attrs{plural})
      {
         $html .= $acros{$attrs{tag}}->{ShortPlural};
      }
      else
      {
         $html .= $acros{$attrs{tag}}->{Short};
      }

      if ($attrs{'case'} eq 'uc')
      {
         $html = uc($html);
      }
      elsif ($attrs{'case'} eq 'ucfirst')
      {
         $html = ucfirst($html);
      }

      &handle_html(&hs_popup("acr_".$attrs{tag}.".html", $html));
   }
   else
   {
      $acros{$attrs{tag}}->{Used} = 1;

      if ($attrs{prefix} and $acros{$attrs{tag}}->{PrefixFirst})
      {
         $html = $acros{$attrs{tag}}->{PrefixFirst};
      }

      if ($attrs{plural})
      {
         if (defined($acros{$attrs{tag}}->{LongPlural}))
         {
            $html .= $acros{$attrs{tag}}->{LongPlural};
         }
         else
         {
            $html .= $acros{$attrs{tag}}->{Long} . 's';
         }

         $html .= '(';

         if (defined($acros{$attrs{tag}}->{ShortPlural}))
         {
            $html .= $acros{$attrs{tag}}->{ShortPlural};
         }
         else
         {
            $html .= $acros{$attrs{tag}}->{Short} . 's';
         }

         $html .= ')';
      }
      else
      {
         $html .= $acros{$attrs{tag}}->{Long}
               . ' (' . $acros{$attrs{tag}}->{Short} . ')';
      }

      if ($attrs{'case'} eq 'uc')
      {
         $html = uc($html);
      }
      elsif ($attrs{'case'} eq 'ucfirst')
      {
         $html = ucfirst($html);
      }

      &hs_index_term('acr_'.$attrs{tag}, $html, ucfirst($html), \%terms);
   }

   my $csname = 'gls';

   if ($attrs{prefix})
   {
      $csname = "p$csname";
   }

   if ($attrs{'case'} eq 'uc')
   {
      $csname = uc($csname);
   }
   elsif ($attrs{'case'} eq 'ucfirst')
   {
      $csname = ucfirst($csname);
   }

   if ($attrs{plural})
   {
      $csname .= 'pl';
   }

   &handle_tex("\\", $csname, "{", $attrs{tag}, "}");
}

sub end_acr{
   my ($expat) = @_;
}
 
sub start_term{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'term' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $hstag = "gls_".$attrs{tag};

   unless ($terms{$hstag})
   {
      die "Unknown term tag '$hstag' on line ",
         $expat->current_line, "\n";
   }

   &check_boolean_attribute_value('prefix', $expat, \%attrs);
   &check_boolean_attribute_value('plural', $expat, \%attrs);

   if (!defined($attrs{'case'}))
   {
      $attrs{'case'} = 'none';
   }

   unless ($attrs{'case'}=~/^none|uc(first)?$/)
   {
      die "Unknown case value '", $attrs{'case'}, "' for term '",
       $attrs{'tag'}, "' on line", $expat->current_line, "\n";
   }

   my $html = '';

   if ($attrs{plural})
   {
      if ($attrs{prefix} and $terms{$hstag}->{PrefixPlural})
      {
         $html = $terms{$hstag}->{PrefixPlural};
      }

      if (defined($terms{$hstag}->{Plural}))
      {
         $html .= $terms{$hstag}->{Plural};
      }
      else
      {
         $html .= $terms{$hstag}->{Text} . 's';
      }
   }
   else
   {
      if ($attrs{prefix} and $terms{$hstag}->{Prefix})
      {
         $html = $terms{$hstag}->{Prefix};
      }

      $html .= $terms{$hstag}->{Text};
   }

   if ($attrs{case} eq 'uc')
   {
      $html = uc($html);
   }
   elsif ($attrs{case} eq 'ucfirst')
   {
      $html = ucfirst($html);
   }

   if (!defined($terms{$hstag}->{Ref}) and $#nodes > -1)
   {
      $terms{$hstag}->{Ref} = $nodes[$#nodes]->{Tag} . ".html#$hstag";
   }

   my $desctag = $hstag;

   if (defined($terms{$hstag}->{Alias}))
   {
      $desctag = "gls_".$terms{$hstag}->{Alias};

      unless ($terms{$desctag})
      {
         die "Unknown alias '$desctag' for term tag '$hstag' on line ",
            $expat->current_line, "\n" ;
      }
   }

   my $csname = 'gls';

   if ($attrs{prefix})
   {
      $csname = "p$csname";
   }

   if ($attrs{'case'} eq 'uc')
   {
      $csname = uc($csname);
   }
   elsif ($attrs{'case'} eq 'ucfirst')
   {
      $csname = ucfirst($csname);
   }

   if ($attrs{plural})
   {
      $csname .= 'pl';
   }

   if ($terms{$desctag}->{Description})
   {
      $html = &hs_popup("$desctag.html", $html);

      &handle_tex("\\$csname\{", $attrs{tag}, "}");
   }
   else
   {
      &handle_tex("\\$csname\{$hstag}");
   }

   &hs_index_term($hstag, $html, $terms{$hstag}->{Text}, 
     \%terms);

}

sub end_term{
   my ($expat) = @_;
}

sub start_plural{
   my ($expat, %attrs) = @_;

   $attrs{plural} = 1;
   &start_term($expat, %attrs);
}

sub end_plural{
   my ($expat) = @_;
}

sub start_ref{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'ref' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   if ($attrs{case})
   {
      unless ($attrs{case}=~/^none|ucfirst$/)
      {
         die "Invalid 'case' attribute '", $attrs{case}, "' for 'ref' element on line ",
           $expat->current_line, "\n";
      }
   }
   else
   {
      $attrs{case} = 'none';
   }

   push @currentattrs, \%attrs;
   push @currenttag, $attrs{tag};
   push @current, 'Ref';
   $texelements{Ref} = '';
   $docinfo{Ref} = '';
}

sub end_ref{
   my ($expat) = @_;

   my $attrs = pop @currentattrs;
   my $tag = pop @currenttag;
   pop @current; 

   my $texcontent = $texelements{Ref};
   my $htmlcontent = $docinfo{Ref};

   if ($texcontent)
   {
      if ($attrs->{case} eq 'ucfirst')
      {
         &handle_tex("\\hyperref[{$tag}]{\\makefirstuc{$texcontent}}");
      }
      else
      {
         &handle_tex("\\hyperref[{$tag}]{$texcontent}");
      }
   }
   else
   {
      if ($attrs->{case} eq 'ucfirst')
      {
         &handle_tex("\\Docautoref{", $tag, "}");
      }
      else
      {
         &handle_tex("\\docautoref{", $tag, "}");
      }
   }

   &handle_html("<ref case=\"", $attrs->{case}, "\" tag=\"$tag\">", $htmlcontent, "</ref>");
}
 
sub start_opt{
   my ($expat, %attrs) = @_;

   unless ($attrs{tag})
   {
      die "Missing 'opt' element's 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   my $text = $attrs{tag};

   unless ($terms{options})
   {
      &hs_index_term('options', '', &get_label('manual.options'), \%terms);

      my %hash = ();

      $terms{options}->{Children} = \%hash;
   }

   my $tag = 'opt_'.$attrs{tag};

   $terms{options}->{Children}->{$tag}->{Parent} = 'options';

   &hs_index_term($tag, "<span class=\"opt\">-$text</span>", $text, 
      $terms{options}->{Children});

   &handle_tex("\\opt{", $attrs{tag}, "}");
}

sub end_opt{
   my ($expat) = @_;
}

sub start_backslash{
   my ($expat, %attrs) = @_;

   &handle_html("<code>\\</code>");

   &handle_tex("\\texttt{\\char`\\\\}");
}

sub end_backslash{
   my ($expat) = @_;
}

sub start_doublebackslash{
   my ($expat, %attrs) = @_;

   &handle_html("<code>\\\\</code>");

   &handle_tex("\\cs{\\char`\\\\}");
}

sub end_doublebackslash{
   my ($expat) = @_;
}

sub start_cs{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('tag', 'cs', \&cs_fmt, $expat, %attrs);
}

sub end_cs{
   my ($expat) = @_;
}

sub start_env{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'env', \&firstofone, $expat, %attrs);
}

sub end_env{
   my ($expat) = @_;
}

sub start_envvar{
   my ($expat, %attrs) = @_;

   &handle_semantic_term('name', 'envvar', \&firstofone, $expat, %attrs);
}

sub end_envvar{
   my ($expat) = @_;
}

sub start_caption{
   my ($expat, %attrs) = @_;

   if ($#current >= 0 and $current[$#current] eq 'TableHeader')
   {
      die "<caption> must come before <tableheader>";
   }

   push @current, 'Caption';
   $docinfo{Caption} = '';
   $texelements{Caption} = '';
}

sub end_caption{
   my ($expat) = @_;
   pop @current;

   if ($#float_elements < 0)
   {
      die "Element 'caption' found outside <float>";
   }

   my $attrs = $float_elements[$#float_elements];

   my $endcaptag;

   if ($attrs->{type} eq 'figure')
   {
      &handle_html('<figcaption>');
      $endcaptag = 'figcaption';
   }
   elsif ($attrs->{type} eq 'table')
   {
      &handle_html('<caption>');
      $endcaptag = 'caption';
   }
   else
   {
      &handle_html('<div class="floatcaption">');
      $endcaptag = 'div';
   }

   &handle_html($tags{$attrs->{tag}}->{Text}, ': ',
     $docinfo{Caption}, "</$endcaptag>");

   if ($attrs->{long})
   {
      &handle_tex("\\caption");

      if ($attrs->{listcaption})
      {
         &handle_tex("[", $attrs->{listcaption}, "]");
      }

      &handle_tex("{", $texelements{Caption}, "}\\label{", $attrs->{tag}, "}%\n");
      &handle_tex("\\tabularnewline ");
   }
}

sub start_subcaption{
   my ($expat, %attrs) = @_;
   push @current, 'SubCaption';
   $docinfo{SubCaption} = '';
   $texelements{SubCaption} = '';
}

sub end_subcaption{
   my ($expat) = @_;
   pop @current;
# TODO
}

sub start_float{
   my ($expat, %attrs) = @_;

   unless ($attrs{type})
   {
      die "Element 'float' missing 'type' attribute on line ",
        $expat->current_line, "\n";
   }

   unless ($attrs{tag})
   {
      die "Element 'float' missing 'tag' attribute on line ",
        $expat->current_line, "\n";
   }

   &check_boolean_attribute_value('long', $expat, \%attrs);

   my $specs = '';

   if ($attrs{type} eq 'table')
   {
      unless ($attrs{spec})
      {
         die "Element 'float' with type='table' missing 'spec' attribute on line ",
            $expat->current_line;
      }

      my @specarray = ();

      while ($attrs{spec}=~/([rlc])|(?:(p)\{(\d+)\%\})/g)
      {
         my $align = (defined($1) ? $1 : $2);

         if ($align eq 'p')
         {
            $specs .= ">{\\raggedright}$align\{" . (0.01*$3) . "\\textwidth}";
            push @specarray, 'l';
         }
         else
         {
            $specs .= $align;
            push @specarray, $align;
         }
      }

      my %hash =
      (
         spec => \@specarray,
         column => 1
      );

      push @tabular_specs, \%hash;

   }
   elsif ($attrs{long})
   {
      die "Element 'float' can only have long='true' with type='table' on line ",
            $expat->current_line;
   }

   my $pos = ($attrs{pos}? "[$attrs{pos}]" : '');

   if ($counters{$attrs{type}})
   {
      $counters{$attrs{type}}++;
   }
   else
   {
      $counters{$attrs{type}} = 1;
   }

   $attrs{counter} = $counters{$attrs{type}};

   push @float_elements, \%attrs;

   # JavaHelp doesn't seem to support 'id' as a fragment.
   # Link to float only seems to work with 'a' element before
   # table/figure element.

   &handle_html("<a name=\"$attrs{tag}\"></a>");

   if ($attrs{type}=~/figure|table/)
   {
      &handle_html("<", $attrs{type});
   }
   else
   {
      &handle_html("<div class=\"float\"");
   }

   &handle_html(">");

   $tags{$attrs{tag}}->{Ref} = $nodes[$#nodes]->{Tag}
     .'.html#'.$attrs{tag};
   $tags{$attrs{tag}}->{Text} = ucfirst(&get_label('manual.'.$attrs{type}))
        . '&nbsp;' . $attrs{counter};

   if ($attrs{long})
   {
      if ($attrs{tabcolsep})
      {
         &handle_tex("\\begingroup\\setlength\\tabcolsep{",
            $attrs{tabcolsep}, "}");
      }
      &handle_tex("\\begin{longtable}{", $specs, '}');
   }
   else
   {
      &handle_tex("\\begin{", $attrs{type}, "}$pos\n");

      if ($attrs{tabcolsep})
      {
         &handle_tex("\\setlength\\tabcolsep{", $attrs{tabcolsep}, "}");
      }

      &handle_tex("\\floatconts{", $attrs{tag}, "}{");

      if ($attrs{type} eq 'table')
      {
         &handle_tex("\\begin{tabular}{", $specs, '}');
      }
   }
   $skipnewline = 1;
}

sub end_float{
   my ($expat) = @_;

   my $attrs = pop @float_elements;

   my $endtag = $attrs->{type};

   if ($attrs->{long})
   {
      &handle_tex('\\end{longtable}');

      if ($attrs->{tabcolsep})
      {
         &handle_tex("\\endgroup ");
      }
   }
   else
   {
      if ($attrs->{type} eq 'table')
      {
         &handle_tex($texelements{TableFooter});
         &handle_tex('\\end{tabular}');
      }

      &handle_tex("}{\\caption");

      if ($attrs->{listcaption})
      {
         &handle_tex("[", $attrs->{listcaption}, "]");
      }

      &handle_tex("{", $texelements{Caption}, "}}%\n\\end{", $attrs->{type}, "}\n");
   }

   if ($attrs->{type} eq 'table')
   {
      pop @tabular_specs;
   }
}

sub start_tableheader{
   my ($expat, %attrs) = @_;

   if ($#float_elements < 0 or $float_elements[$#float_elements]->{type} ne 'table')
   {
      die "Element 'tableheader' found outside <float type='table'>";
   }

   my $attrs = $float_elements[$#float_elements];

   if ($#current >= 0 and $current[$#current] eq 'Caption')
   {
      die "<caption> must come before <tableheader>";
   }

   push @current, 'TableHeader';
   $docinfo{TableHeader} = '';
   $texelements{TableHeader} = '';

   &handle_tex("\\toprule ");
   $skipnewline = 1;
}

sub end_tableheader{
   my ($expat) = @_;

   my $attrs = $float_elements[$#float_elements];

   pop @current;

   &handle_html($docinfo{TableHeader});
   &handle_tex($texelements{TableHeader});

   &handle_tex("\\midrule ");

   if ($attrs->{long})
   {
      &handle_tex("\\endfirsthead\\caption[]{");

      if ($attrs->{listcaption})
      {
         &handle_tex($attrs->{listcaption});
      }
      else
      {
         &handle_tex($texelements{Caption});
      }

      &handle_tex(" \\emph{(\\continuedcaptiontext)}");

      &handle_tex("}\\tabularnewline ");
      &handle_tex($texelements{TableHeader});
      &handle_tex("\\midrule\\endhead\n");
   }
   $skipnewline = 1;
}

sub start_tablefooter{
   my ($expat, %attrs) = @_;

   if ($#float_elements < 0 or $float_elements[$#float_elements]->{type} ne 'table')
   {
      die "Element 'tablefooter' found outside <float type='table'>";
   }

   my $attrs = $float_elements[$#float_elements];

   push @current, 'TableFooter';
   $docinfo{TableFooter} = '';
   $texelements{TableFooter} = "\\bottomrule ";
   $skipnewline = 1;
}

sub end_tablefooter{
   my ($expat) = @_;

   my $attrs = $float_elements[$#float_elements];

   pop @current;

   if ($attrs->{long})
   {
      &handle_tex($texelements{TableFooter});

      my $specarray = $tabular_specs[$#tabular_specs]->{spec};

      &handle_tex("\\multicolumn{", scalar(@$specarray), 
        "}{r}{\\emph{\\continuednextpagetext}}\\endfoot\n");

      &handle_tex($texelements{TableFooter}, "\\endlastfoot ");
   }
   $skipnewline = 1;
}

sub start_tabular{
   my ($expat, %attrs) = @_;

   unless ($attrs{spec})
   {
      die "Element 'tabular' missing 'spec' attribute on line ",
         $expat->current_line;
   }

   &handle_html('<table>');

   my @specarray = ();
   my $specs = '';

   while ($attrs{spec}=~/([rlc])|(?:(p)\{(\d+)\%\})/g)
   {
      my $align = $1;

      if ($align eq 'p')
      {
         $specs .= ">{\\raggedright}$align\{" . (0.01*$2) . "\\textwidth}";
         push @specarray, 'l';
      }
      else
      {
         $specs .= $align;
         push @specarray, $align;
      }
   }

   &handle_tex("\\begin{tabular}{", $specs, '}');

   my %hash =
   (
      spec => \@specarray,
      column => 1
   );

   push @tabular_specs, \%hash;
}
 
sub end_tabular{
   my ($expat) = @_;

   &handle_html('</table>');

   pop @tabular_specs;

   &handle_tex("\\end{tabular}");
}

sub start_tr{
   my ($expat, %attrs) = @_;

   &check_boolean_attribute_value('prohibitbreak', $expat, \%attrs);
   &check_boolean_attribute_value('rule', $expat, \%attrs);

   unless (defined($attrs{prohibitbreak}))
   {
      $attrs{prohibitbreak} = 0;
   }

   unless (defined($attrs{rule}))
   {
      $attrs{rule} = 0;
   }

   $tabular_specs[$#tabular_specs]->{column} = 1;
   $tabular_specs[$#tabular_specs]->{rowattrs} = \%attrs;

   &handle_html('<tr>');
   $skipnewline = 1;
}

sub end_tr{
   my ($expat) = @_;

   &handle_html('</tr>');

   &handle_tex("\\tabularnewline");

   if ($tabular_specs[$#tabular_specs]->{rowattrs}->{prohibitbreak})
   {
      &handle_tex('*');
   }
   else
   {
      &handle_tex(' ');
   }

   if ($tabular_specs[$#tabular_specs]->{rowattrs}->{rule})
   {
      &handle_tex('\\midrule ');
   }

   $skipnewline = 1;
}

sub start_td{
   my ($expat, %attrs) = @_;

   my $colspan = 1;

   if ($attrs{colspan})
   {
      $colspan = $attrs{colspan};

      unless ($colspan=~/^\d+$/)
      {
         die "Attribute 'colspan' must be an integer on line ",
           $expat->current_line, "\n";
      }
   }

   my $column_index = $tabular_specs[$#tabular_specs]->{column}-1;

   my $orgcolspec = $tabular_specs[$#tabular_specs]->{spec}->[$column_index];

   my $colspec = $orgcolspec;

   my $tag = 'td';

   if ($#current >=0 and $current[$#current] eq 'TableHeader')
   {
      $tag = 'th';
      $colspec = 'c';
   }

   if ($attrs{spec})
   {
      $colspec = $attrs{spec};
   }

   my $htmlcolspan = ($colspan == 1 ? '' : "colspan=\"$colspan\"");

   if ($colspec eq 'l')
   {
      &handle_html("<$tag align=\"left\" $htmlcolspan");

      if (defined($attrs{indent}))
      {
         &handle_html(' style="left-margin: ', $attrs{indent}, ';"');
      }

      &handle_html('>');
   }
   elsif ($colspec eq 'r')
   {
      &handle_html("<$tag align=\"right\" $htmlcolspan");

      if (defined($attrs{indent}))
      {
         &handle_html(' style="left-margin: ', $attrs{indent}, ';"');
      }

      &handle_html('>');
   }
   elsif ($colspec eq 'c')
   {
      &handle_html("<$tag align=\"center\" $htmlcolspan");

      if (defined($attrs{indent}))
      {
         &handle_html(' style="left-margin: ', $attrs{indent}, ';"');
      }

      &handle_html('>');
   }

   unless ($tabular_specs[$#tabular_specs]->{column} == 1)
   {
      &handle_tex("&");
   }

   if (($orgcolspec eq $colspec) and $colspan == 1)
   {
      $tabular_specs[$#tabular_specs]->{egroup} = '';
   }
   else
   {
      &handle_tex("\\multicolumn{$colspan}{$colspec}{");
      $tabular_specs[$#tabular_specs]->{egroup} = '}';
   }

   if ($tag eq 'th')
   {
      if ($colspan == 1)
      {
         &handle_tex("\\columnheaderfont ");
      }
      else
      {
         &handle_tex("\\multicolumnheaderfont ");
      }
   }

   if (defined($attrs{indent}))
   {
      &handle_tex("\\hangindent ", $attrs{indent}, " ");
      &handle_tex("\\hskip ", $attrs{indent}, " ");
   }

   $tabular_specs[$#tabular_specs]->{column} += $colspan;

   $skipnewline = 1;
}

sub end_td{
   my ($expat) = @_;

   if ($#current >=0 and $current[$#current] eq 'TableHeader')
   {
      &handle_html('</th>');
   }
   else
   {
      &handle_html('</td>');
   }

   &handle_tex($tabular_specs[$#tabular_specs]->{egroup});
}

sub start_printglossary{
   my ($expat, %attrs) = @_;

   &handle_tex("\\printmainglossary");
}

sub end_printglossary{
   my ($expat) = @_;
}
 
sub start_printindex{
   my ($expat, %attrs) = @_;

   &handle_tex("\\printmainindex ");
}

sub end_printindex{
   my ($expat) = @_;
}
 
sub start_br{
   my ($expat, %attrs) = @_;

   &handle_html("<br />");

   &handle_tex("\\\\");
}

sub end_br{
   my ($expat) = @_;
}

sub start_hr{
   my ($expat, %attrs) = @_;

   &handle_html("<hr />");

   &handle_tex("\\hrulefill ");
}

sub end_hr{
   my ($expat) = @_;
}

sub start_cont{
   my ($expat, %attrs) = @_;

   &handle_tex("\\continueline ");
}

sub end_cont{
   my ($expat) = @_;
}

sub start_contexplan{
   my ($expat, %attrs) = @_;

  &handle_tex(&get_label('manual.cont_explanation'));
}


sub end_contexplan{
   my ($expat) = @_;
}

sub start_percent{
   my ($expat, %attrs) = @_;

   &handle_html("%");
   &handle_tex("\\%");
}

sub end_percent{
   my ($expat) = @_;
}

sub load_dict{
   my %dict;
   my $fd;
   open $fd, "<:encoding($encoding_file)", $mainclass
     or die "Can't open main class file '$mainclass' $!\n";

   while (<$fd>)
   {
      if (/public +static +final +String +APP_NAME *= *"([^"]+)"/)
      {
         $dict{appname} = $1;
      }
      elsif (/public +static +final +String +APP_VERSION *= *"([^"]+)"/)
      {
         $dict{appversion} = $1;
      }
      elsif (/public +static +final +String +APP_DATE *= *"([^"]+)"/)
      {
         $dict{appdate} = $1;
      }
   }

   close $fd;

   my $propfile = "$dictdir/$base-$locale.prop";

   if (not (-e $propfile) and ($lang ne $locale))
   {
      $propfile = "$dictdir/$base-$lang.prop";
   
      unless (-e $propfile)
      {
         die "Can't find either '$dictdir/$base-$locale.prop' or '$propfile'\n";
      }
   }
   
   unless (-e $propfile)
   {
      die "Can't find '$propfile'\n";
   }

   open $fd, "<:encoding($encoding_xml)", $propfile
      or die "Can't open property file '$propfile' $!\n";

   $_ = <$fd>;

   if (/# Encoding: ([^s]+)/)
   {
      my $prop_encoding = $1;

      if ($prop_encoding ne $encoding_xml)
      {
         close $fd;
         open $fd, "<:encoding($prop_encoding)", $propfile
           or die "Can't open property file '$propfile' $!\n";
      }
   }
   else
   {
      die "Encoding comment line missing from line 1 of '$propfile'\n";
   }

   my $linenum = 0;

   my $openquote = chr(hex(2018));
   my $closequote = chr(hex(2019));

   while (<$fd>)
   {
      $linenum++;

      next if (/^ *#/ or /^ *$/);

      if (/^([^=]+)=(.*)$/)
      {
         my $dictkey = $1;
         my $value = $2;

         $value=~s/\\{1}[nt]/ /g;
         $value=~s/(\w)''(\w)/$1$closequote$2/g;
         $value=~s/'{2}([^']+)'{2}/$openquote$1$closequote/g;
         $value=~s/'{2}/$closequote/g;
         $value=~s/\|([a-zA-Z]+)\|/\\cs{$1}/g;

         # strip any trailing ellipsis
         $value=~s/\.{3}$//g;

         # Prop files don't contain any literal {n,...,...}
         # Don't need the complexity of the Java application here.
         # (Many of the messages aren't used in the manual.)

         $value=~s/\{\d,choice,[^\}]+\|<([^\}]*)\}/$1/g;

         $value=~s/\{(\d+)(,[^\}]+)?\}/&arg_placeholder($1)/eg;

         $dict{$dictkey} = $value;

      }
      else
      {
         warn "$propfile: Can't parse line $linenum\n";
      }
   }

   close $fd;

   return %dict;
}

# HTMLEditorKit only provides limited CSS support.
# See API for javax.swing.text.html.CSS
sub write_css{
   my $cssfd;

   open $cssfd, ">:encoding($encoding_file)", $cssfile
     or die "Can't open CSS file '$cssfile' $!\n";

   print $cssfd <<_END_CSS;
\@charset "$encoding_xml";

.title
{
  display: inline;
  font-weight: bold;
  font-size: xx-large;
  text-align: center;
}
.author
{
  display: inline;
  font-weight: bold;
  font-size: large;
  text-align: center;
  padding: 2em;
}
.date
{
  display: inline;
  font-weight: bold;
  font-size: normal;
  text-align: center;
}
.float
{
   text-align: center;
   padding-top: 16;
}
.file
{
   font-family: monospace;
}
.cli
{
   font-family: monospace;
}
.env
{
   font-family: monospace;
}
.envvar
{
   font-family: monospace;
}
.opt
{
   font-family: monospace;
}
.menu
{
   font-family: sans-serif;
   font-weight: bold;
}
.qquad
{
   border-left: 2em;
}
kbd
{
  padding-left: 2px;
  padding-right: 2px;
  color: purple;
  font-weight: bold;
  background-color: #eeeeee;
}
_END_CSS

   close $cssfd;
}

sub write_hs_file{
   my $hsfd;
   open $hsfd, ">:$encoding_file", "$helpsetdir/$base.hs"
     or die "Can't open '$helpsetdir/$base.hs' $!\n";

   my $toctitle = &get_label('manual.toc');
   my $manualtitle = &get_label('manual.title');
   my $indextitle = &get_label('manual.index');
   my $searchtitle = &get_label('manual.search');

   print $hsfd <<_END_HS_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
<!DOCTYPE helpset
PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp HelpSet Version 2.0//EN"
"http://java.sun.com/products/javahelp/helpset_2_0.dtd">


<helpset version="2.0">
   <!-- title -->
   <title>$manualtitle</title>
   <!-- maps -->
   <maps>
   <homeID>top </homeID>
   <mapref location="Map.jhm" />
   </maps>

   <!-- views -->
   <view xml:lang="$locale" mergetype="javax.help.UniteAppendMerge">
      <name>TOC</name>
      <label>$toctitle</label>
      <type>javax.help.TOCView</type>
      <data>${base}TOC.xml</data>
   </view>
   <view xml:lang="$locale" mergetype="javax.help.SortMerge">
      <name>Index</name>
      <label>$indextitle</label>
      <type>javax.help.IndexView</type>
      <data>${base}Index.xml</data>
   </view>
   <view xml:lang="$locale">
      <name>Search</name>
      <label>$searchtitle</label>
      <type>javax.help.SearchView</type>
         <data engine="com.sun.java.help.search.DefaultSearchEngine">
         JavaHelpSearch
         </data>
   </view>
   <!-- presentation windows -->
   <!-- main window -->
   <presentation default=true>
      <name>main window</name>
      <size width="600" height="600" />
      <location x="200" y="200" />
      <title>$manualtitle</title>
      <toolbar>
         <helpaction image="homeIcon">javax.help.HomeAction</helpaction>
         <helpaction image="backIcon">javax.help.BackAction</helpaction>
         <helpaction image="forwardIcon">javax.help.ForwardAction</helpaction>
      </toolbar>
      <image>appIcon</image>
   </presentation>
   <!-- secondary window -->
   <presentation displayviews=false>
      <name>secondary window</name>
      <size width="450" height="500" />
      <location x="200" y="200" />
      <image>appIcon</image>
   </presentation>
   <!-- implementation section -->
   <impl>
      <helpsetregistry helpbrokerclass="javax.help.DefaultHelpBroker" />
      <viewerregistry viewertype="text/html"
         viewerclass="com.sun.java.help.impl.CustomKit"/>
      <viewerregistry viewertype="text/xml"
          viewerclass="com.sun.java.help.impl.CustomXMLKit" />
   </impl>
</helpset>
_END_HS_HEAD

   close $hsfd;
}

sub write_home_file{
   my $htmlfd;

   open $htmlfd, ">:encoding($encoding_file)", "$helpsetdir/$base.html"
     or die "Can't open '$helpsetdir/$base.html' $!\n";

   print $htmlfd &html_head($docinfo{Title}, '', $nodes[0]->{Tag});

   print $htmlfd "<body>\n";

   print $htmlfd "<div class=\"title\" ><h1>", $docinfo{Title}, "</h1>\n";

   print $htmlfd "<p>$docinfo{Author}</p>\n" if ($docinfo{Author});

   print $htmlfd "</div><div class=\"date\">";

   print $htmlfd "<p>$docinfo{Date}</p>\n" if ($docinfo{Date});

   print $htmlfd "</div>";

   if ($docinfo{Boilerplate})
   {
      print $htmlfd '<div class="boilerplate">';
      print $htmlfd $docinfo{Boilerplate};
      print $htmlfd '</div>';
   }

   print $htmlfd &html_nav('', $nodes[0]);

   print $htmlfd "</body>\n</html>\n";

   close $htmlfd;
}

sub html_head{
  my ($title, $prev, $next) = @_;

  $title = 'Untitled' unless($title);

# JEditorPane has very limited CSS support so can't use any fancy
# styling (like borders).

  my $head = <<_END_HTML_HEAD;
<!DOCTYPE html  html public "-//w3c//dtd xhtml 1.0 Transitional//en"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
>
<html xmlns="http://www.w3.org/1999/xhtml" lang="$locale" xml:lang="$locale">
<head>
  <link rel="stylesheet" type="text/css" href="$base.css" />
  <title>$title</title>
  <meta http-equiv="Content-Type" content="text/html; charset=$encoding_xml" />
_END_HTML_HEAD

  if ($next)
  {
     $head .= "<link rel=\"next\" href=\"$next.html\" />";
  }

  if ($prev)
  {
     $head .= "<link rel=\"prev\" href=\"$prev.html\" />";
  }

  "$head</head>";
}

sub write_toc_file{
   my $prev = $base;

   my $tocfd;
   open $tocfd, ">:encoding($encoding_file)", "$helpsetdir/${base}TOC.xml" 
      or die "Can't open '$helpsetdir/${base}TOC.xml' $!\n";

   print $tocfd <<_END_TOC_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
   <!DOCTYPE toc
     PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp TOC Version
2.0//EN"
     "http://java.sun.com/products/javahelp/toc_2_0.dtd">

<toc version="2.0" xml:lang="$locale">
<tocitem text="Manual" target="top" >
_END_TOC_HEAD

   my $prevlevel = 0;

   for (my $idx = 0; $idx <= $#nodes; $idx++)
   {
      my $node = $nodes[$idx];

      for (my $level = scalar(keys %section_levels); $level >= 0; $level--)
      {
         if ($section_levels{$node->{Type}}+$level <= $prevlevel)
         {
            print $tocfd "</tocitem>\n";
         }
      }

      print $tocfd "<tocitem text=\"$node->{Title}\" target=\"$node->{Tag}\">\n";

      my $next = ($idx == $#nodes ? '' : $nodes[$idx+1]);

      my $tag = $node->{Tag};

      open my $htmlfd, ">:encoding($encoding_file)", "$helpsetdir/$tag.html"
        or die "Can't open '$helpsetdir/$tag.html' $!\n";

      print $htmlfd &html_head($node->{Title}, 
        ($prev eq $base ? $base : $prev->{Tag}),
        ($next ? $next->{Tag} : ''));

      print $htmlfd "<body>\n";

      my $header = 'h'.$section_levels{$node->{Type}};

      print $htmlfd "<$header>", $node->{Title}, "</$header>\n";

      my $content = $node->{Contents};

      $content=~s/<ref case="(none|ucfirst)" tag="([^"]+)">(.*?)<\/ref>/&get_ref($1,$2,$3)/eg;

      print $htmlfd "<div>$content</div>";

      if ($node->{Footnotes})
      {
         $content = $node->{Footnotes};

         $content=~s/<ref case="(none|ucfirst)" tag="([^"]+)">(.*?)<\/ref>/&get_ref($1,$2,$3)/eg;

         print $htmlfd "<hr />$content";
      }

      print $htmlfd &html_nav($prev, $next);

      print $htmlfd "</body>\n</html>\n";

      close $htmlfd;

      $prev = $node;
      $prevlevel = $section_levels{$node->{Type}};
   }

   for (my $level = scalar(keys %section_levels); $level >= 0; $level--)
   {
      if ($level < $prevlevel)
      {
         print $tocfd "</tocitem>\n";
      }
   }

   print $tocfd "</tocitem>\n</toc>\n";

   close $tocfd;
}

sub html_nav{
  my ($prevNode, $nextNode) = @_;

  my $nav = '<hr /><table width="100%"><tr><td align="left">';

  if ($prevNode)
  {
     my $prev;
     my $title;

     if ($prevNode eq $base)
     {
        $prev = $base;
        $title = &get_label('manual.home');
     } 
     else
     {
        $prev = $prevNode->{Tag};
        $title = $prevNode->{Title};
     }

     $nav .= "<a href=\"$prev.html\">&#x21E6; " .
      $title . "</a>";
  }

  $nav .= '</td><td align="right">';

  if ($nextNode)
  {
     $nav .= "<a href=\"$nextNode->{Tag}.html\">"
          . $nextNode->{Title}
          . " &#x21E8;</a>";
  }

  "$nav</td></tr></table>"
}

sub write_map_file{

   my $mapfd;
   open $mapfd, ">:encoding($encoding_file)", "$helpsetdir/Map.jhm"
     or die "Can't open '$helpsetdir/Map.jhm' $!\n";

   print $mapfd <<_END_MAP_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
<!DOCTYPE map
 PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp Map Version 2.0//EN"
     "http://java.sun.com/products/javahelp/map_2_0.dtd">
<map version="2.0" xml:lang="$locale">
_END_MAP_HEAD

   print $mapfd "<mapID target=\"top\" url=\"$base.html\" />\n";
   print $mapfd "<mapID target=\"appIcon\" url=\"../../../../icons/flowframtklogosmall.png\" />\n";
   print $mapfd "<mapID target=\"homeIcon\" url=\"../../sharedimages/home.png\" />\n";
   print $mapfd "<mapID target=\"backIcon\" url=\"../../sharedimages/back.png\" />\n";
   print $mapfd "<mapID target=\"forwardIcon\" url=\"../../sharedimages/forward.png\" />\n";

   &hs_map_id($mapfd, \%tags);
   &hs_map_id($mapfd, \%terms);

   print $mapfd "</map>\n";
   close $mapfd;
}

sub write_index_file{
   my $idxfd;
   open $idxfd, ">:encoding($encoding_file)", "$helpsetdir/${base}Index.xml"
    or die "Can't open '$helpsetdir/${base}Index.xml' $!\n";

   print $idxfd <<_END_IDX_HEAD;
<?xml version='1.0' encoding='$encoding_xml' ?>
   <!DOCTYPE index
     PUBLIC "-//Sun Microsystems Inc.//DTD JavaHelp Index Version 2.0//EN"
     "http://java.sun.com/products/javahelp/index_2_0.dtd">

<index version="2.0">
_END_IDX_HEAD

   &print_idx_entries($idxfd, \%terms);

   print $idxfd "</index>\n";
   close $idxfd;
}

sub print_idx_entries{
   my ($idxfd, $hash) = @_;

   foreach my $key (keys %$hash)
   {
      if ($hash->{$key}->{Text})
      {
         my $text = $hash->{$key}->{Text};

         $text=~s/<\/?[^>]*>//g;

         print $idxfd "<indexitem text=\"",
           $text, "\" target=\"",
           $key, "\">\n";

         if ($hash->{$key}->{Children})
         {
            &print_idx_entries($idxfd, $hash->{$key}->{Children});
         }

         print $idxfd "</indexitem>\n";
      }
      else
      {
         warn "Text not set for '$key'.\n";
      }
   }
}

sub hs_map_id{
   my ($mapfd, $hash) = @_;

   foreach my $tag (keys %$hash)
   {
      if ($hash->{$tag}->{Ref})
      {
         print $mapfd "<mapID target=\"$tag\" url=\"$hash->{$tag}->{Ref}\" />\n";
      }
      else
      {
         warn "No Ref found for '$tag'\n";
      }

      if ($hash->{$tag}->{Children})
      {
         &hs_map_id($mapfd, $hash->{$tag}->{Children});
      }
   }
}

sub write_language_defs{

   open my $fd, ">:encoding($encoding_file)", $langdeffile
     or die "Can't open language def file '$langdeffile' $!\n";

   print $fd "\\def\\applang{$locale}\n";
   print $fd "\\def\\idxpackagename{", &get_label('manual.idxpackage')."}\n";
   print $fd "\\def\\idxenvname{", &get_label('manual.idxenv')."}\n";
   print $fd "\\def\\examplename{", &get_label('manual.example')."}\n";
   print $fd "\\def\\abbrvname{", &get_label('manual.abbreviations'), "}\n";
   print $fd "\\def\\continuedcaptiontext{", &get_label('manual.cont.cap.text'), "}\n";
   print $fd "\\def\\continuednextpagetext{",
      &get_label('manual.cont.nextpage.text'), "}\n";

   if (defined ($dict{'manual.page'}))
   {
      print $fd "\\def\\plabelautorefname{" . $dict{'manual.page'} . "}\n";
   }

   foreach my $counter (keys %counters)
   {
      if (defined ($dict{"manual.$counter"}))
      {
         print $fd "\\def\\${counter}autorefname{" . $dict{"manual.$counter"} . "}\n";
      }
   }

   foreach my $counter (keys %section_levels)
   {
      if (defined ($dict{"manual.$counter"}))
      {
         print $fd "\\def\\${counter}autorefname{" . $dict{"manual.$counter"} . "}\n";
      }
   }

   close $fd;
}

sub arg_placeholder{
   "<ARG#" . ($_[0]) . "/>";
}
 
1;
